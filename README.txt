Świetnie, mam wszystko czego potrzebuję. Rozpoczynam pełną analizę projektu `kampania1939_fixed` pod kątem jego struktury, funkcjonalności oraz systemu tur. Skupię się szczególnie na mechanizmie tury opisanym przez Ciebie i sprawdzę, które elementy są już zaimplementowane, co działa, a co trzeba jeszcze połączyć lub dopisać.

Wrócę z dokładnym raportem moduł po module, mapą zależności i propozycją integracji systemu tur zgodnie z Twoją koncepcją.

# Analiza systemu tury i modułów gry kampania1939_fixed

## System tur i fazy gry

**Przebieg faz:** Gra przewiduje kolejność faz: ekran startowy (wybór nacji), następnie tura głównodowodzącego („generała”), potem podtury dowódców podległych tej nacji, a na końcu przekazanie tury przeciwnikowi. W aktualnej implementacji część tej sekwencji jest zaimlementowana w interfejsie, ale brakuje pełnego powiązania między fazami. 

- **Ekran startowy:** Plik `gui/ekran_startowy.py` odpowiada za początek gry. Umożliwia wybór nacji („Polska” lub „Niemcy”) i uruchamia okno panelu generała wybranej strony. Po kliknięciu przycisku nacja jest przekazywana do metody `open_panel_generala()`, która chowa ekran startowy i tworzy okno panelu generała (przekazując m.in. obiekt ekonomii). Ekran startowy działa poprawnie – przyciski wyboru nacji funkcjonują i otwierają odpowiednie okno.

- **Panel Generała:** Okno generała jest zdefiniowane w module `gui/panel_generala...`. W projekcie istnieją dwa pliki: `panel_generalapolska.py` i `panel_generalaniemcy.py`, z czego **`OknoGenerala`** (klasa okna generała) została zaimplementowana jako uniwersalna w pliku niemieckiego generała z parametrem określającym nację. Panel generała tworzy nowe okno typu `tk.Toplevel` z tłem, mapą globalną, sekcją ekonomiczną, sekcją rozkazów i zegarem. Przykładowo, dla mapy globalnej ładowany jest obraz całej mapy heksagonalnej (plik `mapa_hex.jpg`) – kod próbuje go wczytać poprzez ścieżkę zdefiniowaną w zasobach. Sekcja ekonomii wyświetla raport ekonomiczny generowany przez przekazany system ekonomii (w tej chwili używany jest `MockEconomySystem` zwracający przykładowy tekst). Sekcja rozkazów jest na razie szczątkowa – tylko etykieta "Brak rozkazów", co wskazuje, że mechanizm przydzielania głównych rozkazów nie został zaimplementowany. Panel posiada też sekcję czasu z odliczaniem oraz przycisk „Zakończ turę”.  

- **Podtury dowódców:** Dla faz dowódców przygotowano odrębne okna w module `gui`. Istnieją cztery klasy: `PanelDowodcyPolska1`, `PanelDowodcyPolska2`, `PanelDowodcyNiemcy1`, `PanelDowodcyNiemcy2` – odpowiadające dwóm dowódcom po każdej stronie. Każdy z tych paneli jest oknem `tk.Toplevel` z własną częścią mapy (odpowiedni wycinek dla dowódcy), zegarem i przyciskiem kończącym turę. Przykładowo *PanelDowódcy Polska 1* wczytuje obraz `mapa_dowodca1.jpg` jako tło mapy taktycznej dla pierwszego dowódcy, analogicznie *PanelDowódcy Polska 2* korzysta z `mapa_dowodca2.jpg`. Panele dowódców nie mają obecnie interaktywnych elementów sterowania jednostkami – brak na przykład przycisków do zakupu czy przemieszczania oddziałów, jedynie sama mapa i zegar.

- **Zmiana tury na przeciwnika:** W pliku logiki tur `core/tura.py` zaimplementowano funkcję `end_turn()` określającą zmianę strony po zakończeniu tury. Funkcja ta wywołuje rozliczenie ekonomiczne kończącego gracza i zwraca nazwę następnej nacji oraz gracza (np. po „Polska” następują „Niemcy”). Jednak obecnie brak jest kodu, który wykorzystywałby tę logikę w interfejsie – **po zamknięciu okna generała aplikacja wraca do ekranu startowego**, zamiast automatycznie przejść do podtur dowódców i kolejnej nacji. Panel generała kończy turę jedynie zamykając swoje okno (niszcząc `Toplevel`) i nie otwiera nic dalej. Co prawda, panele dowódców wywołują po zamknięciu tzw. callback (`next_turn_callback`) – mechanizm przekazany w konstruktorze, aby poinformować o zakończeniu podtury. Ten mechanizm mógłby uruchamiać kolejnego dowódcę lub kolejną fazę, ale w aktualnym kodzie **nie został spięty z panelem generała**. W rezultacie sekwencja tury nie jest w pełni zautomatyzowana. 

**Brakujące elementy:** Należy zaimplementować kontroler sekwencji tur, który po zakończeniu etapu generała automatycznie otworzy podtury dowódców, a po ich zakończeniu – rozpocznie turę drugiej nacji. Można to rozwiązać np. w metodzie `open_panel_generala` ekranu startowego, zastępując proste przywrócenie menu logiką: po `mainloop()` generała wywołać serię okien dowódców danej strony (wykorzystując `next_turn_callback` do łańcuchowego otwarcia kolejnych dowódców), a następnie dopiero utworzyć panel generała strony przeciwnej. Innym podejściem jest rozszerzenie klasy `OknoGenerala` – jej metoda kończąca turę mogłaby bezpośrednio otwierać pierwsze okno dowódcy (przekazując mu callback do otwarcia drugiego, itd.). Finalnie, po przejściu podtur dowódców, należałoby wywołać funkcję `core.tura.end_turn()` by rozliczyć turę i pobrać nazwę następnej nacji, a następnie utworzyć dla niej okno generała. Aktualny brak integracji tych kroków to główna luka w systemie tur. Uzupełnienie tego mechanizmu – czyli **zintegrowanie interfejsu z logiką zmiany tury** – jest kluczowe, aby gra przechodziła płynnie przez wszystkie fazy zamiast zatrzymywać się po pierwszej. 

## Integracja mapy z rozkazami i zasobami

**Pliki mapy:** W folderze `gui/mapa_cyfrowa/` znajdują się pliki mapy: główna mapa w formacie JPG (`mapa_globalna.jpg` oraz wariant z siatką hex `mapa_hex.jpg`) oraz dwa pliki map częściowych dla dowódców (`mapa_dowodca1.jpg` i `mapa_dowodca2.jpg`). Jest tam też plik `mapa_dane.json` zawierający dane mapy (konfigurację siatki, kluczowe punkty itp.). Obecna integracja polega na wyświetlaniu tych grafik w interfejsie, ale bez interakcji z logiką gry. Panel generała wczytuje obraz całej mapy (heksagonalnej) i wyświetla go na kanwie jako tło, natomiast każdy panel dowódcy pokazuje swój wycinek mapy (np. sektor dowódcy 1). To zapewnia wizualizację pola bitwy, jednak **nie ma jeszcze powiązania między kliknięciami na mapę a logiką rozkazów czy jednostkami** – obrazy służą tylko jako tło informacyjne.

**Dane mapy (`mapa_dane.json`):** Załadunkiem danych mapy zajmuje się moduł pomocniczy `utils/loader.py`. Funkcja `load_map_data(json_path)` czyta plik JSON i przygotowuje strukturę słownika z informacjami o heksach, typach terenu, domyślnych modyfikatorach oraz konfiguracją siatki. W kodzie widać zamiar przechowywania m.in. współrzędnych środków wszystkich heksów (`hex_centers`), danych każdego heksu (np. rodzaj terenu, obecna jednostka) oraz parametrów siatki (rozmiar heksa, liczba kolumn i rzędów). Aktualny plik JSON jest jednak ubogi – zawiera tylko konfigurację (wymiary siatki i ścieżkę do obrazka tła) i puste struktury na teren i punkty kluczowe. `loader.py` przewiduje generowanie współrzędnych heksów poprzez funkcję `mapa.generate_hex_positions` jeśli nie są one zdefiniowane w pliku, lecz moduł `model/mapa.py` nie zawiera tej implementacji (plik jest pusty). Oznacza to, że choć struktura do integracji mapy z logiką jest naszkicowana, **brakuje wypełnienia danych i użycia ich w mechanice gry**. 

**Logika rozkazów:** W założeniach gry generał po obejrzeniu mapy globalnej miał wydawać główne rozkazy (np. „utrzymaj punkt X” lub „zdobądź Y”) dla poszczególnych dowódców, a dowódcy mieli na swoich podmapach realizować te zadania ruchami jednostek i atakami. W kodzie jednak mechanizm rozkazów nie został zaimplementowany. Moduł `core/rozkazy.py` definiuje jedynie szkic klasy `OrdersManager` bez konkretnej logiki. W panelu generała sekcja „Rozkazy” to na razie statyczny tekst, a w panelach dowódców brak jakichkolwiek elementów do przyjmowania czy wyświetlania rozkazów. Interakcja między graczem a mapą (np. kliknięcie heksu, wybór jednostki, wydanie komendy ruchu) nie została jeszcze zrealizowana. Tym samym **integracja mapy z logiką rozkazów jest w fazie początkowej** – mamy wyświetlanie mapy, przygotowany format danych heksów, ale brakuje implementacji interakcji. 

**Zasoby i punkty ekonomiczne na mapie:** Przydział zasobów terytorialnych (np. kontrola kluczowych punktów na mapie dająca punkty) czy powiązanie ekonomii z mapą także nie jest gotowe. Plik JSON przewiduje sekcję `key_points` (punkty kluczowe), potencjalnie do oznaczenia miast, fabryk itp., jednak jest ona pusta. W `core/ekonomia.py` planowane jest odzwierciedlenie zdarzeń ekonomicznych (np. produkcja krajowa co turę, losowe eventy jak kryzys, wsparcie sojuszników), ale nie ma bezpośredniego związku z kontrolą mapy, bo brakuje logiki sprawdzającej np. przejęcie punktu na mapie. **Przydział punktów ekonomicznych dowódcom** (o którym mowa w założeniach projektu) również nie został zaimplementowany – aktualnie system ekonomii śledzi punkty na poziomie nacji globalnie. W interfejsie generała brak jest opcji rozdysponowania punktów pomiędzy dowódców. Prawdopodobnie zamierzano dodać w panelu generała mechanizm alokacji (np. wpisanie ile punktów otrzyma dany dowódca), lecz obecnie sekcja ekonomii tylko wyświetla sumaryczny raport, a sekcja rozkazów jest pusta. 

**Sugestie integracji mapy:** Aby w pełni zintegrować mapę z rozgrywką, należy uzupełnić dane mapy (koordynaty heksów, typy terenu, punkty strategiczne) i wykorzystać je w module jednostek. Konieczne będzie zaimplementowanie klasy `Jednostka` i logiki jej ruchu po heksach oraz ataku (najlepiej poprzez powiązanie `OrdersManager` z interakcjami na kanwie mapy). Można np. po kliknięciu na jednostkę i docelowy heks generować rozkaz ruchu, który zostanie zapisany w strukturze rozkazów i przetworzony na zmiany w modelu `mapa`. Generał mógłby wydawać ogólne rozkazy poprzez interfejs (np. wybór punktu docelowego na mapie globalnej, który zostaje przypisany dowódcy), co następnie pojawi się w panelu dowódcy jako cel do zrealizowania. Takie powiązanie wymaga dodania komunikacji między oknem generała a oknami dowódców (przekazanie rozkazów – np. poprzez wspólny obiekt gry albo zapisywanie w modelu, do którego dowódcy mogą się odwołać). 

Również **przydział punktów ekonomicznych** warto związać z mapą – np. kontrola kluczowych miast może zwiększać produkcję, a generał może alokować zasoby do regionów (dowódców) w zależności od potrzeb frontu. W panelu generała można dodać kontrolki pozwalające podzielić punkty (np. pola tekstowe lub suwaki dla każdego dowódcy, sumujące do dostępnej puli). Aktualnie EconomySystem obsługuje punkty globalnie na nację, więc ewentualny podział można odzwierciedlić po stronie interfejsu (odejmując z globalnej puli i przekazując wartość dowódcy – np. jako parametr przy otwieraniu panelu dowódcy, by mógł wiedzieć ile ma do wydania na nowe jednostki). 

Podsumowując, **mapa jest zintegrowana z grą tylko wizualnie**, a brak logiki heksów i rozkazów oznacza, że kluczowe elementy (ruchy wojsk, kontrola terytorium, wpływ terenu na walkę) są jeszcze do napisania. Uzupełnienie tego modułu wymaga zarówno wprowadzenia danych (edytor mapy lub ręczne uzupełnienie `mapa_dane.json`), jak i napisania kodu obsługi tych danych w interfejsie (zdarzenia kliknięć) i logice (aktualizacja stanu modelu mapy i jednostek). 

## Generator żetonów i integracja z grą

**Edytor żetonów:** W folderze `edytory/` znajduje się narzędzie `token_editor_prototyp.py`, które służy do generowania **żetonów jednostek** (czyli jednostek grywalnych) wraz z ich parametrami. Jest to aplikacja Tkinter uruchamiana niezależnie od głównej gry – ma własne okno interfejsu do wprowadzania parametrów jednostki (typ, wielkość, punkty ruchu, wartość ataku, obrona, koszty itp.). Edytor pozwala wybrać nację, rodzaj jednostki (np. piechota P pluton, kawaleria K itp.), jej rozmiar (pluton, kompania itd.), a także określić dodatkowe wsparcia (np. sekcja ckm, pojazdy) wpływające na statystyki. Na podstawie tych danych generuje się grafika żetonu – edytor rysuje tło z flagą odpowiedniej nacji oraz nakłada symbole/jednostki (to sugeruje fragment kodu z generowaniem tła flagi dla danej nacji). Finalnie użytkownik edytora może zapisać żeton – co powoduje wygenerowanie pliku PNG z grafiką oraz pliku JSON z danymi jednostki. Te pliki są zapisywane do struktury katalogów w folderze `tokeny/`, podzielonych na podfoldery per nacja („polskie” i „niemieckie”) i dalej na typy jednostek. W dostarczonym archiwum widać przykładowe wygenerowane żetony, np. `Polska P Pluton` (polski pluton piechoty) z odpowiednim obrazem PNG i plikiem `token_data.json` zawierającym jego parametry. Przykładowe dane takiego żetonu obejmują m.in.: punkty ruchu, zasięg i siłę ataku, wartość walki wręcz, koszt utrzymania jednostki (`unit_maintenance`) oraz koszt zakupu (`purchase_value`). 

**Wczytywanie żetonów do gry:** Główna gra nie generuje żetonów w locie – zamiast tego korzysta z wygenerowanych plików. Za integrację odpowiada funkcja `load_tokens_from_folder` w `utils/loader.py`, która przegląda katalog `tokeny/` i wczytuje wszystkie dostępne jednostki. Kod ten tworzy listy słowników z informacjami o żetonach dla każdej nacji osobno. Wykrywa pliki `.png` i odpowiadające im `token_data.json`, ładuje statystyki z JSON i przypisuje jednostkę do listy polskiej lub niemieckiej na podstawie nazwy/nacji. Dzięki temu gra potencjalnie ma dostęp do pełnej bazy jednostek do wykorzystania w rozgrywce. **Aktualnie jednak brak jest implementacji, która by te listy wykorzystała podczas rozgrywki.** Moduły GUI (panel generała, panel dowódcy) nie prezentują listy dostępnych jednostek do zakupu, nie ma też mechanizmu wydawania punktów na zakup. Prawdopodobnie planowano, by dowódcy w swojej turze mogli dokupywać jednostki za przydzielone punkty – wspomina o tym specyfikacja („Zakup nowych jednostek i ich wystawienie na mapę” w fazie dowódcy). W kodzie brakuje jednak GUI sklepu z jednostkami. Istnieje co prawda pakiet `store/` z modułem `sklep.py`, ale nie został on załadowany ani użyty w interfejsie (być może miał obsługiwać mikrotransakcje lub zakup jednostek za punkty, lecz nie widać jego integracji). 

- **Ekonomia a zakup jednostek:** System ekonomii (`core/ekonomia.py`) przechowuje punkty ekonomiczne danej nacji i pozwala je modyfikować. Ma metody dodawania przychodu (`add_income`) i wydatku (`add_expense`) oraz ogólny `process_turn`, który m.in. odejmuje koszty utrzymania za posiadane jednostki w turze. Parametr `cost_per_unit` w `process_turn` najwyraźniej ma reprezentować koszt utrzymania pojedynczej jednostki, mnożony przez ich liczbę (`unit_count`). Wygenerowane żetony mają atrybut `unit_maintenance` – co sugeruje, że docelowo mechanizm utrzymania będzie bardziej zróżnicowany (różne typy jednostek mogą mieć różny koszt utrzymania). Obecna implementacja `process_turn` jest uproszczona do jednego uśrednionego kosztu dla wszystkich. **Zakup jednostek** nie został zaimplementowany, ale można przypuszczać, że miał wykorzystywać `purchase_value` z danych żetonu – przy zakupie jednostki należałoby wywołać `EconomySystem.add_expense(nation, cost)` dla kosztu zakupu, i utworzyć obiekt jednostki na mapie. Tego jednak w kodzie brak: klasy w `model/jednostka.py` czy `model/zasoby.py` są puste, więc nie ma struktury do utworzenia instancji jednostki podczas gry.

**Stopień ukończenia:** Generator żetonów jako osobna aplikacja jest **gotowy i działający** – można tworzyć i zapisywać nowe jednostki. Integracja z grą jest **częściowo gotowa** po stronie wczytywania danych (loader przygotuje listy jednostek dostępnych dla obu stron). Natomiast **brakuje interfejsu w grze do korzystania z tych danych**. Gracz nie ma sposobu by zobaczyć jakie jednostki może kupić ani dokonać zakupu. Ponadto, brak jest implementacji dodawania nowo zakupionej jednostki na mapę (wymagałoby to dodania jednostki do modelu mapy i wyświetlenia jej ikony na kanwie mapy dowódcy). 

**Integracja proponowana:** Należy rozbudować panele dowódców o możliwość zarządzania jednostkami. Można to zrobić poprzez dodanie panelu listy dostępnych żetonów wraz z przyciskiem zakupu. Na przykład, w oknie dowódcy mógłby pojawić się panel boczny lub popup wyświetlający listę żetonów (pobranych z `polish_tokens` lub `german_tokens` w zależności od nacji) wraz z ich ceną (`purchase_value`). Po wybraniu jednostki i potwierdzeniu zakupu, jeśli dowódca ma wystarczającą ilość przydzielonych punktów, system ekonomii powinien zostać zaktualizowany (`add_expense` dla kosztu) a nowa jednostka dodana do gry. Trzeba tu zaimplementować utworzenie obiektu jednostki (np. stworzyć instancję klasy `Jednostka` z parametrami z JSON) i umieszczenie jej na mapie (przypisanie do odpowiedniego heksu w strukturze mapy oraz narysowanie na kanwie, np. jako obrazek tokenu w odpowiedniej skali). Dobrze byłoby wykorzystać istniejące grafiki żetonów – np. wczytać `ImageTk.PhotoImage` z pliku PNG jednostki i wyświetlić go na mapie dowódcy. Integracja generatora z GUI mogłaby też objąć opcję importu nowych jednostek bez restartu gry (np. gdyby edytor był dostępny z poziomu menu, ale to poza podstawowym zakresem). Priorytetem jest jednak umożliwienie wykorzystania puli jednostek wygenerowanych przez edytor w trakcie rozgrywki oraz wiązanie tego z systemem ekonomii (wydawanie i odejmowanie punktów, ograniczenie zakupów do posiadanych środków). 

## Timer tury i jego wpływ na rozgrywkę

**Implementacja zegara:** Zarówno w panelu generała, jak i w panelach dowódców, zaimplementowano odliczanie czasu tury. Kod wykorzystuje metodę `after` tkintera do zlecenia wykonywania funkcji co sekundę. W klasie `OknoGenerala` (oraz analogicznych klasach dowódców) zdefiniowano metodę `start_timer()`, która zmniejsza licznik pozostałego czasu i aktualizuje etykietę z wyświetlanym czasem. Czas początkowy jest ustawiony na 5 minut (300 sekund) dla każdej fazy, co widać w inicjalizacji `self.remaining_time = 300` zarówno u generała, jak i dowódców. Jeśli licznik dojdzie do zera, gra pokazuje komunikat informacyjny i automatycznie kończy turę danej fazy – w przypadku generała wywoływana jest metoda `end_turn()` zamykająca okno, a w przypadku dowódcy metoda `end_turn()` zamyka okno i dodatkowo poprzez callback może zainicjować następną podturę. 

**Wpływ na flow gry:** Dzięki timerowi, każda faza tury ma ograniczenie czasowe – zapobiega to sytuacji, w której gracz mógłby w nieskończoność zastanawiać się nad ruchem. W założeniach projektu wspomniano, że cała tura (generał + dowódcy) powinna trwać maksymalnie 20 minut. Obecna implementacja daje po 5 minut na okno generała i na każde okno dowódcy niezależnie. Jeśli docelowo mają być dwaj dowódcy na stronę, to sumarycznie strona może zużyć ~15 minut, co jest spójne z tą koncepcją (choć brak mechanizmu kontrolującego globalny sumaryczny czas). Działający zegar **wpływa na rozgrywkę o tyle, że wymusza zakończenie fazy** – po upływie czasu okno zamyka się tak samo, jakby gracz nacisnął „Zakończ turę”. W aktualnym stanie gry efekt praktyczny jest identyczny z ręcznym zakończeniem, jako że brak jest akcji wykonywanych w czasie rzeczywistym (gra turowa czeka na decyzje gracza). Gdy interakcje i ruch jednostek zostaną wprowadzone, timer nabierze znaczenia – np. dowódca, któremu skończy się czas, nie zdąży wykonać części ruchów. Z tego powodu implementacja zegara już teraz przygotowuje grunt pod docelową mechanikę ograniczenia czasu na podjęcie decyzji. 

**Ocena gotowości:** Timer jest **w pełni zaimplementowany na poziomie każdego okna** – działa odliczanie co sekundę i zamknięcie okna po czasie. Potrzeba natomiast upewnić się, że po auto-zamknięciu fazy gra przejdzie do kolejnej fazy (co wraca do kwestii integracji sekwencji tur opisanej wyżej). Obecnie, jeżeli czas generała minie, okno generała się zamknie i zostanie przywrócony ekran startowy (bo tak działa `open_panel_generala` wracając do menu po `mainloop()` generała). Docelowo powinno się to zmienić, by zamiast powrotu do menu wywołać turę dowódców lub przeciwnika. Reasumując, **mechanizm odliczania czasu jest gotowy**, wymaga tylko zintegrowania z logiką przechodzenia tur, żeby automatyczne zamknięcie okna od razu wyzwalało kolejne etapy tak samo jak ręczne kliknięcie zakończenia tury. 

## Zapis stanu gry po turze

**Obecny stan:** Aktualna wersja projektu **nie posiada funkcjonalności zapisu stanu gry** po turze (ani w dowolnym momencie). W kodzie nie znaleziono metod ani wywołań zapisujących dane gry do pliku – wyszukiwanie słów kluczowych potwierdza brak takiej implementacji. Moduły modelu (`model/`) miały prawdopodobnie służyć do przechowywania stanu (np. klasy Gracz, Mapa, Jednostka), jednak są one puste lub oznaczone komentarzem „do dalszej implementacji”. W konsekwencji nie istnieje gotowy obiekt czy struktura, którą można by zserializować i zapisać. System ekonomii przechowuje co prawda punkty w `EconomySystem.nations` (słownik), ale nie ma kodu, który by te informacje zrzucał do pliku. Podobnie, ruchy czy wyniki bitew nie są nigdzie zapamiętywane poza potencjalnymi polami w strukturze mapy (której brak). 

**Wymagane dane do zapisu:** Aby zapisać stan gry po turze, należałoby zebrać: 
- **Stany ekonomiczne** obu nacji (punkty ekonomiczne i zaopatrzenia – dostępne w `EconomySystem.nations`), 
- **Rozstawienie jednostek na mapie** – czyli lista wszystkich jednostek, ich typy, pozycje heksowe, przynależność (to wymaga ukończenia modułu modelu jednostek i mapy), 
- **Aktualny etap gry** – np. która tura (numer), czyja kolej itp., 
- **Ewentualnie aktywne rozkazy czy niewykonane cele**, jeśli takie będą śledzone. 

Nic z powyższego nie jest obecnie zapisywane automatycznie. Prawdopodobnie planowano dodać taką opcję w przyszłości (być może w interfejsie generała przy końcu tury albo w menu pauzy). Na razie jednak **nie ma modułu odpowiedzialnego za zapis**. 

**Propozycje rozwiązania:** Można wdrożyć zapis stanu gry po zakończeniu pełnej tury (czyli po turze obu nacji). Na końcu funkcji `core/tura.end_turn()` po ustaleniu następnej nacji można dodać wywołanie np. `save_game_state()` – funkcji, która zbierze dane i zapisze do pliku JSON lub binarnie. Należałoby wypełnić klasy modelu danymi: lista obiektów `Jednostka` powinna zawierać ich parametry (typ, siła, itp. – te dane już są w tokenach) oraz aktualne współrzędne na mapie; klasa `Mapa` powinna umożliwić iterację po heksach i sprawdzenie co na nich jest; klasa `Gracz` mogłaby przechowywać np. posiadane punkty i jednostki. Alternatywnie, można nieco uprościć zapis tworząc strukturę słownikową na podstawie istniejących komponentów: np. słownik z kluczami „economy” (tu dane z EconomySystem), „units” (lista wszystkich jednostek z polami: typ, pozycja, HP itp.), „current_turn” (czyja tura nadchodzi), i zapisać to `json.dump` do pliku. 

Przed implementacją zapisu trzeba jednak uzupełnić brakujące elementy stanu gry (przede wszystkim reprezentację jednostek i mapy). Bez tego zapis nie ma wiele do zarejestrowania poza ekonomią. Warto zauważyć, że moduł `utils/loader.py` mógłby posłużyć nie tylko do wczytywania statycznych danych, ale również do deserializacji stanu gry – można by analogicznie napisać `save_map_data` czy `save_game_state` korzystające z odwrotności struktur użytych w `load_map_data` i listy tokenów. Ponieważ plik `mapa_dane.json` już istnieje, można rozszerzyć jego format o np. pozycje jednostek po każdej turze (choć lepiej mieć oddzielny plik save, by nie mieszać z bazową konfiguracją mapy). 

**Gotowość modułów:** Obecne moduły nie są gotowe do zapisu – brak jest metod typu `to_dict()` w klasach czy innych ułatwień serializacji. Jednak struktura projektu (podział na `model` i `core`) sugeruje, że intencją było oddzielenie logiki i stanu od interfejsu, co jest dobrą podstawą do dodania funkcji zapisu/odczytu gry. Należy wprowadzić mechanizm gromadzenia stanu (np. centralny obiekt gry przechowujący referencje do EconomySystem, mapy i jednostek) i zapewnić jego serializację przy zamknięciu tury. To pozwoliłoby graczom zapisać postęp i ewentualnie później wczytać (choć wczytywanie również trzeba by zaimplementować analogicznie). 

## Podsumowanie modułów i zależności

Poniżej przedstawiono zestawienie głównych modułów/funkcji projektu, z podaniem odpowiedzialnych plików, ich zależności oraz stanu realizacji:

| **Moduł/Funkcja**            | **Pliki źródłowe (ścieżka)**                       | **Zależności**                          | **Status (stan implementacji)**            |
|------------------------------|----------------------------------------------------|-----------------------------------------|--------------------------------------------|
| **Ekran startowy** – wybór nacji, start gry | `gui/ekran_startowy.py`                | Tkinter, importuje `gui.panel_generala` | **Ukończony** (działa wybór Polski/Niemiec i otwarcie okna generała) |
| **Panel Generała** – interfejs tury głównodowodzącego (mapa globalna, ekonomia, rozkazy, zegar) | `gui/panel_generalapolska.py`, `gui/panel_generalaniemcy.py` (klasa `OknoGenerala`) | Tkinter, PIL (mapa), korzysta z `core.ekonomia` (raport), docelowo z `utils.loader` (mapa) | **Częściowo gotowy** (interfejs graficzny jest, wyświetla mapę i ekonomię, ale brak interakcji: nie przydziela rozkazów, nie łączy się z dowódcami) |
| **Panele Dowódców** – interfejs podtury dowódców (mapa sektora, zegar, zakończenie podtury) | `gui/panel_dowodcypolska1.py`, `...polska2.py`, `...niemcy1.py`, `...niemcy2.py` | Tkinter, PIL (mapa sektora)               | **Częściowo gotowe** (okna z mapą sektorową działają, odliczanie czasu i przycisk „Zakończ turę”; brak zarządzania jednostkami i zakupów) |
| **Logika zmiany tury** – przełączanie aktywnego gracza po turze | `core/tura.py` (funkcje `end_turn`, `is_turn_active`) | `core.ekonomia` (do rozliczenia punktów), wykorzystuje dane nacji | **Częściowo gotowa** (funkcja `end_turn` rozlicza ekonomię i zwraca następną nację, ale nie jest wywoływana w GUI – brak powiązania z końcem okien tur) |
| **System ekonomii** – punkty ekonomiczne i zaopatrzenia, wydarzenia | `core/ekonomia.py` (klasa `EconomySystem`) | `model.zasoby` (stałe – *niezdefiniowane*), `core.tura` (wykorzystuje `process_turn`) | **Prawie gotowy** (logika zarządzania punktami działa: dodawanie, odejmowanie, reset, losowe wydarzenie; brakuje wartości początkowych w `model/zasoby.py` i powiązania z resztą gry) |
| **Pogoda** – generowanie warunków pogodowych wpływających na grę | `core/pogoda.py`                             | Brak (nie używane nigdzie)               | **Niezaimplementowany** (pusty lub szczątkowy moduł; funkcjonalność pogodowa nie występuje jeszcze w grze) |
| **Dyplomacja** – relacje między nacjami (sojusze, wsparcie) | `core/dyplomacja.py`                        | Brak (nie używane)                       | **Niezaimplementowany** (brak kodu wpływającego na grę) |
| **Warunki zwycięstwa** – sprawdzanie końca gry, spełnienia celów | `core/zwyciestwo.py`                        | Brak (nie używane)                       | **Niezaimplementowany** (pusty plik, logika zwycięstwa nieobecna) |
| **Model gry** – klasy reprezentujące stan gry (gracze, mapa, jednostki, zasoby) | `model/gracz.py`, `model/mapa.py`, `model/jednostka.py`, `model/zasoby.py` | Używane przez core (np. `zasoby.py` miał mieć stałe dla ekonomii) | **Niezaimplementowane** (tylko szkielety/komentarze – stan gry faktycznie nie jest utrwalany w tych klasach) |
| **Ładowanie danych** – wczytywanie konfiguracji mapy i dostępnych jednostek | `utils/loader.py`                           | `json`, `tkinter.messagebox`, korzysta z `model.mapa` (generowanie heksów) | **Gotowy w zakresie danych** (potrafi wczytać plik mapy JSON i zorganizować dane, oraz załadować żetony z folderów; generowanie współrzędnych heksów wymaga uzupełnienia w `model/mapa`) |
| **Generator mapy** (edytor map) – narzędzie do tworzenia/edycji map | `edytory/map_editor_prototyp.py`            | Tkinter, PIL, json                       | **Częściowo** (nie analizowano dokładnie, ale prawdopodobnie prototyp do uzupełniania `mapa_dane.json`; nie wpływa na grę bezpośrednio) |
| **Generator żetonów** – tworzenie nowych jednostek (żetonów) | `edytory/token_editor_prototyp.py`          | Tkinter, PIL, `playsound` (opcjonalnie)  | **Ukończony (prototyp)** – pozwala definiować jednostki i zapisuje pliki PNG+JSON; osobny od głównej gry (służy do przygotowania danych jednostek) |
| **Mikropłatności/Sklep** – potencjalny sklep z dodatkami lub jednostkami | `gui/mikroplatnosci.py`, `store/sklep.py`   | Tkinter (GUI), nie używane aktualnie    | **Nieaktywny** (kod istnieje, ale nie jest zintegrowany z rozgrywką; prawdopodobnie planowano dodatki opcjonalne) |
| **Sieć – multiplayer** – tryb gry sieciowej klient/serwer | `net/host.py`, `net/klient.py`, `net/synchronizacja.py` | biblioteka `socket`/`select` itp. (należy przypuszczać) | **Częściowo** (implementacja sieci nie była analizowana szczegółowo; pliki istnieją, ale gra nie wykorzystuje ich w obecnej fazie) |
| **Dostępność – sterowanie głosowe i narracja** | `accessibility/komendy_glosowe.py`, `accessibility/narracja_glosowa.py`, `accessibility/interfejs_wizualny.py` | biblioteki rozpoznawania mowy, TTS (być może) | **Częściowo** (to moduły dodatkowe dla niepełnosprawnych graczy; nie wpływają na rdzeń rozgrywki, mogą być w fazie prototypu) |

**Legenda stanu:** Ukończony – funkcjonalność działa zgodnie z przeznaczeniem; Częściowo – jest implementacja, ale niepełna lub niepodłączona do całości; Niezaimplementowany – moduł jest pusty lub szczątkowy, wymagający napisania od podstaw.

## Wnioski i zalecenia

Projekt **kampania1939_fixed** posiada dobrze rozdzieloną strukturę modułów, lecz wiele z nich to wciąż szkielety. **System tur** wymaga dopracowania po stronie sekwencji – należy połączyć istniejące okna w jedną ciągłość rozgrywki. **Integracja mapy** z logiką gry jest następnym priorytetem: trzeba ożywić mapę, dodać obsługę heksów, jednostek i rozkazów, tak by mapa nie była tylko tłem, ale elementem interaktywnym decydującym o wyniku starć. **Generator żetonów** dostarczył danych jednostek i ta część wydaje się gotowa, teraz jednak kluczowe jest spożytkowanie tych danych w grze – zaimplementowanie **zakupów jednostek za punkty** i wystawiania ich na planszę. System ekonomii jest w znacznej mierze zrobiony (obsługuje punkty, limity, wydarzenia), lecz brakuje mu powiązania z faktycznymi wydatkami gracza (np. zakupami jednostek) i wpływu mapy (kontrola terytoriów) – te powiązania należy dopisać, zgodnie z założeniami designu. **Timer tur** działa poprawnie w izolacji, ale jego pełen sens ujawni się dopiero po spięciu wszystkich faz – dlatego integracja faz (generał -> dowódcy -> przeciwnik) jest tak ważna, by odliczanie czasu mogło kontrolować całą turę zgodnie z zamiarem. Na koniec, dodanie **funkcji zapisu stanu gry** zwiększy użyteczność projektu i umożliwi dłuższą rozgrywkę z przerwami – to jednak wymaga najpierw ugruntowania modelu stanu (jednostki, mapa, itd.). 

Podsumowując, projekt ma już zaimplementowane podstawy interfejsu i kluczowe moduły logiczne (turę, ekonomię) w stopniu minimalnym. **Brakujące elementy** to głównie integracja istniejących klocków i wypełnienie pustych modułów modelu. Najlepszym podejściem będzie iteracyjne dodawanie tych funkcjonalności: najpierw zapewnić przepływ tury między graczami (co odkryje, gdzie potrzebne są dalsze dane, np. stan jednostek), następnie zaimplementować interakcje na mapie i zakup jednostek, a wreszcie umożliwić zapis/odczyt stanu. Z tak przygotowanym szkieletem, gra „Wrzesień 1939” będzie mogła przejść od fazy prototypu do w pełni grywalnej strategicznej rozgrywki turowej. 

