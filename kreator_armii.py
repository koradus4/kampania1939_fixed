"""
KREATOR ARMII - Profesjonalna aplikacja do tworzenia armii
Pe≈Çna automatyzacja, GUI, kontrola parametr√≥w, inteligentne balansowanie
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
from pathlib import Path
import sys
import json
import random
import threading
import time
import shutil
from unittest.mock import patch

# Dodaj ≈õcie≈ºkƒô do edytor√≥w (z g≈Ç√≥wnego folderu projektu)
project_root = Path(__file__).parent
sys.path.append(str(project_root / "edytory"))

class ArmyCreatorStudio:
    def __init__(self, root):
        self.root = root
        self.root.title("üéñÔ∏è Kreator Armii - Kampania 1939")
        self.root.geometry("900x750")  # Zwiƒôkszona wysoko≈õƒá z 600 na 750
        self.root.configure(bg="#556B2F")  # Dark olive green jak w grze
        self.root.resizable(True, True)
        
        # Ikona i style
        self.setup_styles()
        
        # Dane aplikacji (POPRAWIONE - po 2 dow√≥dc√≥w na nacjƒô)
        self.nations = ["Polska", "Niemcy"]
        self.commanders = {
            "Polska": ["1 (Polska)", "2 (Polska)"],
            "Niemcy": ["5 (Niemcy)", "6 (Niemcy)"]
        }
        
        # Typy jednostek z bazowymi kosztami i statystykami
        self.unit_templates = {
            "P": {"name": "Piechota", "base_cost": 25, "weight": 0.4},
            "K": {"name": "Kawaleria", "base_cost": 30, "weight": 0.1},
            "TL": {"name": "Czo≈Çg Lekki", "base_cost": 35, "weight": 0.15},
            "T≈ö": {"name": "Czo≈Çg ≈öredni", "base_cost": 45, "weight": 0.1},
            "TC": {"name": "Czo≈Çg Ciƒô≈ºki", "base_cost": 60, "weight": 0.05},
            "TS": {"name": "Sam. Pancerny", "base_cost": 35, "weight": 0.1},
            "AL": {"name": "Artyleria Lekka", "base_cost": 35, "weight": 0.15},
            "AC": {"name": "Artyleria Ciƒô≈ºka", "base_cost": 55, "weight": 0.1},
            "AP": {"name": "Art. Przeciwlotnicza", "base_cost": 30, "weight": 0.05},
            "Z": {"name": "Zaopatrzenie/Rozpoznanie", "base_cost": 20, "weight": 0.1},
            "D": {"name": "Dow√≥dztwo", "base_cost": 40, "weight": 0.05}
        }
        
        self.unit_sizes = ["Pluton", "Kompania", "Batalion"]
        
        # Zmienne GUI
        self.selected_nation = tk.StringVar(value="Polska")
        self.selected_commander = tk.StringVar(value="1 (Polska)")
        self.army_size = tk.IntVar(value=10)
        self.army_budget = tk.IntVar(value=500)
        self.creating_army = False
        
        # Lista utworzonych jednostek
        self.created_units = []
        
        # Token Editor (zainicjalizowany p√≥≈∫niej)
        self.token_editor = None
        
        self.create_gui()
        self.update_commander_options()
    
    def setup_styles(self):
        """Konfiguracja styl√≥w TTK."""
        style = ttk.Style()
        style.theme_use('clam')
        
        # Kolory motywu wojskowego (jak w grze)
        style.configure('Title.TLabel', 
                       foreground='white', 
                       background='#556B2F',  # Dark olive green
                       font=('Arial', 20, 'bold'))
        
        style.configure('Header.TLabel',
                       foreground='white',
                       background='#556B2F',  # Dark olive green
                       font=('Arial', 12, 'bold'))
        
        style.configure('Military.TButton',
                       font=('Arial', 11, 'bold'),
                       foreground='#556B2F')
        
        style.configure('Success.TButton',
                       font=('Arial', 12, 'bold'),
                       foreground='#6B8E23')  # Olive green jak w grze
        
        style.configure('Danger.TButton',
                       font=('Arial', 12, 'bold'),
                       foreground='#8B0000')
    
    def create_gui(self):
        """Tworzy g≈Ç√≥wny interfejs aplikacji."""
          # Nag≈Ç√≥wek
        header_frame = tk.Frame(self.root, bg="#6B8E23", height=60)  # Olive green jak w grze
        header_frame.pack(fill=tk.X, padx=10, pady=3)
        header_frame.pack_propagate(False)
        
        title_label = ttk.Label(header_frame, 
                               text="üéñÔ∏è KREATOR ARMII", 
                               style='Title.TLabel')
        title_label.pack(expand=True)
        
        subtitle_label = ttk.Label(header_frame,
                                  text="Profesjonalne tworzenie armii dla Kampanii 1939",
                                  style='Header.TLabel')
        subtitle_label.pack()
        
        # G≈Ç√≥wny kontener
        main_frame = tk.Frame(self.root, bg="#556B2F")  # Dark olive green
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
          # Lewa kolumna - Parametry ze scrollbarem
        left_outer_frame = tk.Frame(main_frame, bg="#6B8E23", width=350)
        left_outer_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 5))
        left_outer_frame.pack_propagate(False)
        
        # Canvas ze scrollbarem dla lewej kolumny
        canvas = tk.Canvas(left_outer_frame, bg="#6B8E23", highlightthickness=0)
        scrollbar = ttk.Scrollbar(left_outer_frame, orient="vertical", command=canvas.yview)
        self.scrollable_frame = tk.Frame(canvas, bg="#6B8E23")
        
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Bind scroll events
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        canvas.bind("<MouseWheel>", _on_mousewheel)
        
        self.create_parameters_panel(self.scrollable_frame)
        
        # Prawa kolumna - PodglƒÖd i kontrola
        right_frame = tk.Frame(main_frame, bg="#6B8E23")  # Olive green jak w grze
        right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))
        
        self.create_preview_panel(right_frame)
        
        # Status bar na dole
        self.create_status_bar()
    
    def create_parameters_panel(self, parent):
        """Tworzy panel parametr√≥w armii."""
        
        # Tytu≈Ç sekcji
        ttk.Label(parent, text="‚öôÔ∏è PARAMETRY ARMII", style='Header.TLabel').pack(pady=10)
        
        # Nacja
        nation_frame = tk.Frame(parent, bg="#6B8E23")  # Olive green
        nation_frame.pack(fill=tk.X, padx=20, pady=5)
        
        ttk.Label(nation_frame, text="üè¥ Nacja:", style='Header.TLabel').pack(anchor='w')
        nation_combo = ttk.Combobox(nation_frame, textvariable=self.selected_nation,
                                   values=self.nations, state='readonly', width=25)
        nation_combo.pack(fill=tk.X, pady=2)
        nation_combo.bind('<<ComboboxSelected>>', self.on_nation_change)
        
        # Dow√≥dca
        commander_frame = tk.Frame(parent, bg="#6B8E23")  # Olive green
        commander_frame.pack(fill=tk.X, padx=20, pady=5)
        ttk.Label(commander_frame, text="üë®‚Äç‚úàÔ∏è Dow√≥dca:", style='Header.TLabel').pack(anchor='w')
        
        self.commander_combo = ttk.Combobox(commander_frame, textvariable=self.selected_commander,
                                           state='readonly', width=25)
        self.commander_combo.pack(fill=tk.X, pady=2)
        self.commander_combo.bind('<<ComboboxSelected>>', self.on_commander_change)
        
        # Separator
        ttk.Separator(parent, orient='horizontal').pack(fill=tk.X, padx=20, pady=8)
        
        # Rozmiar armii
        size_frame = tk.Frame(parent, bg="#6B8E23")  # Olive green
        size_frame.pack(fill=tk.X, padx=20, pady=5)
        
        ttk.Label(size_frame, text="üìä Ilo≈õƒá ≈ºeton√≥w:", style='Header.TLabel').pack(anchor='w')
        self.size_scale = tk.Scale(size_frame, from_=5, to=25, orient=tk.HORIZONTAL,
                                  variable=self.army_size, bg="#6B8E23", fg="white",
                                  highlightbackground="#6B8E23", command=self.update_preview)
        self.size_scale.pack(fill=tk.X, pady=2)
        
        # Bud≈ºet VP
        budget_frame = tk.Frame(parent, bg="#6B8E23")  # Olive green
        budget_frame.pack(fill=tk.X, padx=20, pady=5)
        
        ttk.Label(budget_frame, text="üí∞ Bud≈ºet VP:", style='Header.TLabel').pack(anchor='w')
        self.budget_scale = tk.Scale(budget_frame, from_=250, to=1000, orient=tk.HORIZONTAL,
                                    variable=self.army_budget, bg="#6B8E23", fg="white",
                                    highlightbackground="#6B8E23", command=self.update_preview)
        self.budget_scale.pack(fill=tk.X, pady=2)        
        # Separator
        ttk.Separator(parent, orient='horizontal').pack(fill=tk.X, padx=20, pady=8)
        
        # Przyciski akcji
        action_frame = tk.Frame(parent, bg="#6B8E23")  # Olive green
        action_frame.pack(fill=tk.X, padx=20, pady=10)
        
        ttk.Button(action_frame, text="üé≤ Losowa Armia", 
                  command=self.generate_random_army,
                  style='Military.TButton').pack(fill=tk.X, pady=2)
        
        ttk.Button(action_frame, text="‚öñÔ∏è Zbalansuj Auto",
                  command=self.auto_balance_army,
                  style='Military.TButton').pack(fill=tk.X, pady=2)
        
        ttk.Button(action_frame, text="üóëÔ∏è Wyczy≈õƒá",
                  command=self.clear_army,
                  style='Danger.TButton').pack(fill=tk.X, pady=2)
          # G≈Ç√≥wny przycisk tworzenia
        ttk.Separator(parent, orient='horizontal').pack(fill=tk.X, padx=20, pady=10)
        
        self.create_button = ttk.Button(action_frame, text="üíæ UTW√ìRZ ARMIƒò",
                                       command=self.create_army_thread,
                                       style='Success.TButton')
        self.create_button.pack(fill=tk.X, pady=10)
          # Panel zarzƒÖdzania folderami - kompaktowy
        ttk.Separator(parent, orient='horizontal').pack(fill=tk.X, padx=20, pady=3)
        
        management_frame = tk.Frame(parent, bg="#6B8E23")  # Olive green
        management_frame.pack(fill=tk.X, padx=15, pady=3)
        
        # Nag≈Ç√≥wek mniejszy
        header_label = tk.Label(management_frame, text="üóÇÔ∏è ZARZƒÑDZANIE FOLDERAMI", 
                               bg="#6B8E23", fg="white", font=("Arial", 10, "bold"))
        header_label.pack(pady=1)
        
        # Statystyki ≈ºeton√≥w - kompaktowe
        self.stats_frame = tk.Frame(management_frame, bg="#556B2F", relief=tk.RIDGE, bd=1)
        self.stats_frame.pack(fill=tk.X, pady=2)
        
        self.stats_label = tk.Label(self.stats_frame, 
                                   text="üìä Sprawdzanie folder√≥w...", 
                                   bg="#556B2F", fg="white", 
                                   font=("Arial", 8), wraplength=300)
        self.stats_label.pack(pady=1)
        
        # Przyciski czyszczenia - mniejsze
        clean_frame = tk.Frame(management_frame, bg="#6B8E23")
        clean_frame.pack(fill=tk.X, pady=1)
        
        # Ma≈Çe przyciski z mniejszymi fontami
        btn_style = ttk.Style()
        btn_style.configure('Small.Danger.TButton',
                           font=('Arial', 9),
                           foreground='#8B0000')
        btn_style.configure('Small.Military.TButton',
                           font=('Arial', 9),
                           foreground='#556B2F')
        
        ttk.Button(clean_frame, text="üóëÔ∏è Polskie",
                  command=self.clean_polish_tokens,
                  style='Small.Danger.TButton').pack(fill=tk.X, pady=1)
        
        ttk.Button(clean_frame, text="üóëÔ∏è Niemieckie",
                  command=self.clean_german_tokens,
                  style='Small.Danger.TButton').pack(fill=tk.X, pady=1)
        
        ttk.Button(clean_frame, text="üóëÔ∏è WSZYSTKIE",
                  command=self.clean_all_tokens,                  style='Small.Danger.TButton').pack(fill=tk.X, pady=1)
        
        ttk.Button(clean_frame, text="üîÑ Od≈õwie≈º",
                  command=self.refresh_token_stats,
                  style='Small.Military.TButton').pack(fill=tk.X, pady=1)
          # Panel rozstawiania armii na mapie - bardzo kompaktowy
        ttk.Separator(parent, orient='horizontal').pack(fill=tk.X, padx=15, pady=2)
        
        deploy_frame = tk.Frame(parent, bg="#6B8E23")
        deploy_frame.pack(fill=tk.X, padx=15, pady=2)
        
        # Nag≈Ç√≥wek mniejszy
        deploy_label = tk.Label(deploy_frame, text="üó∫Ô∏è MAPA", 
                               bg="#6B8E23", fg="white", font=("Arial", 9, "bold"))
        deploy_label.pack(pady=1)
        
        # Info o ƒáwiartce - bardzo kompaktowe
        self.quarter_info = tk.Label(deploy_frame, text="üìç Wybierz dow√≥dcƒô", 
                                    bg="#556B2F", fg="white", font=("Arial", 7), 
                                    wraplength=300, height=2)
        self.quarter_info.pack(fill=tk.X, pady=1)
        
        # Przyciski rozstawiania - ma≈Çe
        deploy_buttons = tk.Frame(deploy_frame, bg="#6B8E23")
        deploy_buttons.pack(fill=tk.X, pady=1)
        
        # Dodaj style dla bardzo ma≈Çych przycisk√≥w
        btn_style = ttk.Style()
        btn_style.configure('Tiny.Military.TButton',
                           font=('Arial', 8),
                           foreground='#556B2F')
        btn_style.configure('Tiny.Danger.TButton',
                           font=('Arial', 8),
                           foreground='#8B0000')
        
        ttk.Button(deploy_buttons, text="‚öîÔ∏è Rozstaw",
                  command=self.deploy_army_to_map,
                  style='Tiny.Military.TButton').pack(fill=tk.X, pady=1)
        
        ttk.Button(deploy_buttons, text="üìã Info", 
                  command=self.preview_quarter_info,
                  style='Tiny.Military.TButton').pack(fill=tk.X, pady=1)
        
        ttk.Button(deploy_buttons, text="üßπ Wyczy≈õƒá",
                  command=self.clear_army_from_map,
                  style='Tiny.Danger.TButton').pack(fill=tk.X, pady=1)
        
        # Za≈Çaduj poczƒÖtkowe statystyki
        self.refresh_token_stats()
    
    def create_preview_panel(self, parent):
        """Tworzy panel podglƒÖdu armii."""
        
        # Tytu≈Ç sekcji
        ttk.Label(parent, text="üëÅÔ∏è PODGLƒÑD ARMII", style='Header.TLabel').pack(pady=10)
        
        # Informacje o armii
        info_frame = tk.Frame(parent, bg="#6B8E23")  # Olive green
        info_frame.pack(fill=tk.X, padx=20, pady=5)
        
        self.info_label = ttk.Label(info_frame, text="Wybierz parametry aby zobaczyƒá podglƒÖd",
                                   style='Header.TLabel')
        self.info_label.pack()
        
        # Lista jednostek
        list_frame = tk.Frame(parent, bg="#6B8E23")  # Olive green
        list_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        ttk.Label(list_frame, text="üìã Sk≈Çad armii:", style='Header.TLabel').pack(anchor='w')        # Scrolled text dla listy jednostek - mniejszy
        self.units_text = scrolledtext.ScrolledText(list_frame, height=8, width=40,
                                                   bg="white", fg="#556B2F",  # Tekst w kolorze dark olive
                                                   font=('Consolas', 8))
        self.units_text.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Progress bar
        self.progress_frame = tk.Frame(parent, bg="#6B8E23")  # Olive green
        self.progress_frame.pack(fill=tk.X, padx=20, pady=5)
        
        ttk.Label(self.progress_frame, text="Postƒôp tworzenia:", style='Header.TLabel').pack(anchor='w')
        self.progress_bar = ttk.Progressbar(self.progress_frame, mode='determinate')
        self.progress_bar.pack(fill=tk.X, pady=2)
        
        self.progress_label = ttk.Label(self.progress_frame, text="Gotowy do pracy",
                                       style='Header.TLabel')
        self.progress_label.pack()
    
    def create_status_bar(self):
        """Tworzy pasek statusu - kompaktowy."""
        status_frame = tk.Frame(self.root, bg="#556B2F", height=25)  # Zmniejszona wysoko≈õƒá z 30 na 25
        status_frame.pack(fill=tk.X, side=tk.BOTTOM)
        status_frame.pack_propagate(False)
        
        self.status_label = ttk.Label(status_frame, 
                                     text="‚ö° Kreator Armii - Gotowy",
                                     style='Header.TLabel')
        self.status_label.pack(side=tk.LEFT, padx=5, pady=2)  # Zmniejszone pady z 5 na 2
        
        # Informacja o autorze - mniejsza
        author_label = ttk.Label(status_frame,
                                text="Kampania 1939 ¬© 2025",
                                style='Header.TLabel')
        author_label.pack(side=tk.RIGHT, padx=5, pady=2)  # Zmniejszone pady z 5 na 2
    
    def on_nation_change(self, event=None):
        """Obs≈Çuguje zmianƒô nacji."""
        self.update_commander_options()
        self.update_preview()
        self.update_quarter_info()
    
    def on_commander_change(self, event=None):
        """Obs≈Çuguje zmianƒô dow√≥dcy."""
        self.update_preview()
        self.update_quarter_info()

    def update_commander_options(self):
        """Aktualizuje opcje dow√≥dc√≥w dla wybranej nacji."""
        nation = self.selected_nation.get()
        commanders = self.commanders.get(nation, [])
        
        self.commander_combo['values'] = commanders
        if commanders:
            self.selected_commander.set(commanders[0])
        
        # Aktualizuj info o ƒáwiartce po zmianie dow√≥dcy
        self.update_quarter_info()
    
    def update_quarter_info(self):
        """Aktualizuje informacje o wybranej ƒáwiartce."""
        try:
            if hasattr(self, 'quarter_info'):
                nation = self.selected_nation.get()
                commander = self.selected_commander.get()
                quarter = self.get_quarter_for_nation_and_commander(nation, commander)
                
                info_text = f"üìç {quarter['description']}\n"
                info_text += f"üó∫Ô∏è Q: {quarter['q_min']}-{quarter['q_max']}, "
                info_text += f"R: {quarter['r_min']}-{quarter['r_max']}"
                
                self.quarter_info.config(text=info_text)
        except:
            pass  # Ignoruj b≈Çƒôdy podczas inicjalizacji
    
    def update_preview(self, event=None):
        """Aktualizuje podglƒÖd armii."""
        if self.creating_army:
            return
            
        size = self.army_size.get()
        budget = self.army_budget.get()
        nation = self.selected_nation.get()
        
        # Aktualizuj informacje
        avg_cost = budget // size if size > 0 else 0
        self.info_label.config(text=f"üìä {size} ≈ºeton√≥w | üí∞ {budget} VP | ‚öñÔ∏è ~{avg_cost} VP/≈ºeton")
        
        # Wygeneruj przyk≈ÇadowƒÖ armiƒô do podglƒÖdu
        preview_army = self.generate_balanced_army_preview(size, budget)
        
        # Wy≈õwietl w text widget
        self.units_text.delete(1.0, tk.END)
        total_cost = 0
        
        for i, unit in enumerate(preview_army, 1):
            unit_text = f"{i:2}. {unit['type']} {unit['size']} - {unit['cost']} VP\n"
            self.units_text.insert(tk.END, unit_text)
            total_cost += unit['cost']
        
        # Podsumowanie
        self.units_text.insert(tk.END, f"\n{'='*30}\n")
        self.units_text.insert(tk.END, f"SUMA: {total_cost} VP\n")
        self.units_text.insert(tk.END, f"BUD≈ªET: {budget} VP\n")
        self.units_text.insert(tk.END, f"POZOSTA≈ÅO: {budget - total_cost} VP\n")
        
        # Analiza balansu
        self.analyze_army_balance(preview_army)
    
    def generate_balanced_army_preview(self, size, budget):
        """Generuje zbalansowanƒÖ armiƒô do podglƒÖdu."""
        army = []
        remaining_budget = budget
        remaining_slots = size
        
        # Sortuj typy wed≈Çug wagi (od najwa≈ºniejszych)
        sorted_types = sorted(self.unit_templates.items(), 
                             key=lambda x: x[1]['weight'], reverse=True)
        
        for unit_type, template in sorted_types:
            if remaining_slots <= 0 or remaining_budget <= 0:
                break
                
            # Oblicz ile jednostek tego typu chcemy
            desired_count = max(1, int(size * template['weight']))
            actual_count = min(desired_count, remaining_slots, 
                             remaining_budget // template['base_cost'])
            
            for _ in range(actual_count):
                if remaining_slots <= 0 or remaining_budget < template['base_cost']:
                    break
                    
                # Wybierz losowy rozmiar jednostki
                unit_size = random.choice(self.unit_sizes)
                
                # Dostosuj koszt w zale≈ºno≈õci od rozmiaru
                size_multiplier = {"Pluton": 1.0, "Kompania": 1.5, "Batalion": 2.2}
                unit_cost = int(template['base_cost'] * size_multiplier.get(unit_size, 1.0))
                
                # Dodaj losowƒÖ wariacjƒô ¬±20%
                variation = random.uniform(0.8, 1.2)
                unit_cost = int(unit_cost * variation)
                
                if unit_cost <= remaining_budget:
                    army.append({
                        'type': template['name'],
                        'size': unit_size,
                        'cost': unit_cost,
                        'unit_type': unit_type
                    })
                    remaining_budget -= unit_cost
                    remaining_slots -= 1
        
        # Wype≈Çnij pozosta≈Çe sloty tanimi jednostkami
        while remaining_slots > 0 and remaining_budget >= 15:
            cheap_types = [('Z', 'Rozpoznanie'), ('P', 'Piechota')]
            unit_type, type_name = random.choice(cheap_types)
            unit_size = 'Pluton'
            unit_cost = min(remaining_budget, random.randint(15, 25))
            
            army.append({
                'type': type_name,
                'size': unit_size, 
                'cost': unit_cost,
                'unit_type': unit_type
            })
            remaining_budget -= unit_cost
            remaining_slots -= 1
        
        return army
    
    def analyze_army_balance(self, army):
        """Analizuje balans armii i wy≈õwietla statystyki."""
        if not army:
            return
            
        # Policz typy jednostek
        type_counts = {}
        total_cost = sum(unit['cost'] for unit in army)
        
        for unit in army:
            unit_type = unit['unit_type']
            type_counts[unit_type] = type_counts.get(unit_type, 0) + 1
        
        # Wy≈õwietl analizƒô
        self.units_text.insert(tk.END, f"\nüìä ANALIZA BALANSU:\n")
        
        for unit_type, count in sorted(type_counts.items()):
            template = self.unit_templates.get(unit_type, {})
            type_name = template.get('name', unit_type)
            percentage = (count / len(army)) * 100
            self.units_text.insert(tk.END, f"  {type_name}: {count} ({percentage:.0f}%)\n")
    
    def generate_random_army(self):
        """Generuje losowƒÖ armiƒô."""
        size = random.randint(8, 20)
        budget = random.randint(300, 800)
        
        self.army_size.set(size)
        self.army_budget.set(budget)
        self.update_preview()
        
        self.status_label.config(text="üé≤ Wygenerowano losowƒÖ armiƒô")
    def get_map_quarters(self):
        """Dzieli mapƒô na 4 ƒáwiartki dla dow√≥dc√≥w."""
        return {
            "polska_gora": {    # üáµüá± Dow√≥dca 1 - P√≥≈Çnoc
                "q_min": 0, "q_max": 27,
                "r_min": -20, "r_max": 0,
                "nation": "Polska",
                "commander": 1,
                "description": "üáµüá± P√≥≈Çnoc (Dow√≥dca 1)"
            },
            "polska_dol": {     # üáµüá± Dow√≥dca 2 - Po≈Çudnie  
                "q_min": 0, "q_max": 27,
                "r_min": 0, "r_max": 20,
                "nation": "Polska", 
                "commander": 2,
                "description": "üáµüá± Po≈Çudnie (Dow√≥dca 2)"
            },
            "niemcy_gora": {    # üá©üá™ Dow√≥dca 5 - P√≥≈Çnoc
                "q_min": 28, "q_max": 55,
                "r_min": -20, "r_max": 0,
                "nation": "Niemcy",
                "commander": 5, 
                "description": "üá©üá™ P√≥≈Çnoc (Dow√≥dca 5)"
            },
            "niemcy_dol": {     # üá©üá™ Dow√≥dca 6 - Po≈Çudnie
                "q_min": 28, "q_max": 55,
                "r_min": 0, "r_max": 20,
                "nation": "Niemcy",
                "commander": 6,
                "description": "üá©üá™ Po≈Çudnie (Dow√≥dca 6)"
            }
        }
    
    def get_quarter_for_nation_and_commander(self, nation, commander_id):
        """Zwraca odpowiedniƒÖ ƒáwiartkƒô dla nacji i dow√≥dcy."""
        quarters = self.get_map_quarters()
        
        # Mapowanie dow√≥dc√≥w na ƒáwiartki
        if nation == "Polska":
            if commander_id in [1, "1 (Polska)"]:
                return quarters["polska_gora"]
            elif commander_id in [2, "2 (Polska)"]:
                return quarters["polska_dol"]
        elif nation == "Niemcy":
            if commander_id in [5, "5 (Niemcy)"]:
                return quarters["niemcy_gora"] 
            elif commander_id in [6, "6 (Niemcy)"]:
                return quarters["niemcy_dol"]
        
        # Domy≈õlnie pierwsza ƒáwiartka dla nacji
        if nation == "Polska":
            return quarters["polska_gora"]
        else:
            return quarters["niemcy_gora"]
    
    def is_hex_in_quarter(self, hex_coord, quarter):
        """Sprawdza czy hex nale≈ºy do danej ƒáwiartki."""
        try:
            q, r = map(int, hex_coord.split(','))
            return (quarter["q_min"] <= q <= quarter["q_max"] and 
                   quarter["r_min"] <= r <= quarter["r_max"])
        except:
            return False
    
    def get_hexes_in_quarter(self, quarter):
        """Zwraca wszystkie heksy w danej ƒáwiartce."""
        hexes = []
        for q in range(quarter["q_min"], quarter["q_max"] + 1):
            for r in range(quarter["r_min"], quarter["r_max"] + 1):
                hex_coord = f"{q},{r}"
                hexes.append(hex_coord)
        return hexes

    # ...existing code...
    
    def auto_balance_army(self):
        """Automatycznie balansuje armiƒô wed≈Çug optymalnych proporcji."""
        size = self.army_size.get()
        budget = self.army_budget.get()
        
        # Optymalne proporcje dla r√≥≈ºnych rozmiar√≥w armii
        if size <= 8:
            # Ma≈Ça armia - skupiona
            optimal_budget = min(budget, size * 45)
        elif size <= 15:
            # ≈örednia armia - zbalansowana
            optimal_budget = min(budget, size * 35)
        else:
            # Du≈ºa armia - ta≈Ñsze jednostki
            optimal_budget = min(budget, size * 30)
        
        self.army_budget.set(optimal_budget)
        self.update_preview()
        
        self.status_label.config(text="‚öñÔ∏è Armia zosta≈Ça automatycznie zbalansowana")
    
    def clear_army(self):
        """Czy≈õci podglƒÖd armii."""
        self.units_text.delete(1.0, tk.END)
        self.units_text.insert(tk.END, "Armia zosta≈Ça wyczyszczona.\n\nWybierz parametry aby zobaczyƒá nowy podglƒÖd.")
        self.status_label.config(text="üóëÔ∏è Armia wyczyszczona")
    
    def create_army_thread(self):
        """Uruchamia tworzenie armii w g≈Ç√≥wnym wƒÖtku GUI (nieblokujƒÖce)."""
        if self.creating_army:
            return
            
        self.creating_army = True
        
        try:
            # Aktualizuj GUI
            self.create_button.config(state='disabled', text="‚è≥ TWORZENIE...")
            self.status_label.config(text="üè≠ Tworzenie armii w toku...")
            
            # Wygeneruj finalnƒÖ armiƒô
            size = self.army_size.get()
            budget = self.army_budget.get()
            self.final_army = self.generate_final_army(size, budget)
            
            # Inicjalizuj Token Editor
            self.progress_label.config(text="Inicjalizacja Token Editor...")
            self.initialize_token_editor()
            
            # Rozpocznij sekwencyjne tworzenie ≈ºeton√≥w
            self.current_unit_index = 0
            self.total_units = len(self.final_army)
            self.root.after(100, self.create_next_token)
            
        except Exception as e:
            self.creation_failed(str(e))
    
    def create_next_token(self):
        """Tworzy kolejny ≈ºeton w sekwencji (nieblokujƒÖce)."""
        if self.current_unit_index >= self.total_units:
            # Wszystkie ≈ºetony utworzone
            self.creation_completed(self.total_units)
            return
            
        unit = self.final_army[self.current_unit_index]
        progress = ((self.current_unit_index + 1) / self.total_units) * 100
        
        # Aktualizuj progress
        self.update_creation_progress(progress, f"Tworzenie: {unit['name']}")
        
        # Utw√≥rz ≈ºeton
        try:
            self.create_single_token(unit)
            self.current_unit_index += 1
            # Zaplanuj nastƒôpny ≈ºeton za 500ms
            self.root.after(500, self.create_next_token)
        except Exception as e:
            print(f"B≈ÇƒÖd tworzenia ≈ºetonu {unit['name']}: {e}")
            self.current_unit_index += 1
            # Kontynuuj mimo b≈Çƒôdu
            self.root.after(500, self.create_next_token)
    
    def generate_final_army(self, size, budget):
        """Generuje finalnƒÖ armiƒô z dok≈Çadnymi nazwami jednostek."""
        nation = self.selected_nation.get()
        commander_full = self.selected_commander.get()
        commander_num = commander_full.split()[0]
        
        # Bazowa armia
        base_army = self.generate_balanced_army_preview(size, budget)
        
        # Konwertuj na finalne jednostki z nazwami
        final_army = []
        for i, unit in enumerate(base_army, 1):
            unit_data = self.convert_to_final_unit(unit, nation, commander_num, i)
            final_army.append(unit_data)
        
        return final_army
    
    def convert_to_final_unit(self, preview_unit, nation, commander_num, index):
        """Konwertuje jednostkƒô podglƒÖdu na finalnƒÖ jednostkƒô z pe≈Çnymi danymi."""
        
        # S≈Çowniki nazw dla r√≥≈ºnych nacji
        if nation == "Polska":
            unit_names = {
                "P": [f"{commander_num}. Pu≈Çk Piechoty", f"{commander_num}. Batalion Strzelc√≥w", f"{commander_num}. Kompania Grenadier√≥w"],
                "K": [f"{commander_num}. Pu≈Çk U≈Çan√≥w", f"{commander_num}. Szwadron Kawalerii", f"{commander_num}. Oddzia≈Ç Jazdy"],
                "TL": [f"{commander_num}. Pluton Tankietek", f"{commander_num}. Kompania Czo≈Çg√≥w Lekkich", f"{commander_num}. Batalion Pancerny"],
                "T≈ö": [f"{commander_num}. Pluton Czo≈Çg√≥w", f"{commander_num}. Kompania Pancerna", f"{commander_num}. Batalion Czo≈Çg√≥w"],
                "AL": [f"{commander_num}. Bateria Artylerii", f"{commander_num}. Dywizjon Artylerii", f"{commander_num}. Pu≈Çk Artylerii"],
                "AC": [f"{commander_num}. Bateria Ciƒô≈ºka", f"{commander_num}. Dywizjon Ciƒô≈ºki", f"{commander_num}. Pu≈Çk Artylerii Ciƒô≈ºkiej"],
                "Z": [f"{commander_num}. Oddzia≈Ç Rozpoznawczy", f"{commander_num}. Kompania Zaopatrzeniowa", f"{commander_num}. Batalion Wsparcia"]
            }
        else:  # Niemcy
            unit_names = {
                "P": [f"{commander_num}. Infanterie Regiment", f"{commander_num}. Grenadier Bataillon", f"{commander_num}. Sch√ºtzen Kompanie"],
                "TL": [f"{commander_num}. Panzer Zug", f"{commander_num}. Panzer Kompanie", f"{commander_num}. Panzer Abteilung"],
                "T≈ö": [f"{commander_num}. schwere Panzer", f"{commander_num}. Panzer Regiment", f"{commander_num}. Panzer Brigade"],
                "AL": [f"{commander_num}. Artillerie Batterie", f"{commander_num}. Artillerie Abteilung", f"{commander_num}. Artillerie Regiment"],
                "AC": [f"{commander_num}. schwere Artillerie", f"{commander_num}. Haubitze Abteilung", f"{commander_num}. schwere Artillerie Regiment"],
                "Z": [f"{commander_num}. Aufkl√§rungs Zug", f"{commander_num}. Versorgungs Kompanie", f"{commander_num}. Unterst√ºtzungs Bataillon"]
            }
        
        unit_type = preview_unit['unit_type']
        names_list = unit_names.get(unit_type, [f"{commander_num}. {preview_unit['type']} Einheit"])
        unit_name = random.choice(names_list)
        
        # Generuj statystyki na podstawie kosztu i typu
        cost = preview_unit['cost']
        base_stats = self.generate_unit_stats(unit_type, preview_unit['size'], cost)
        
        return {
            "name": unit_name,
            "nation": nation,
            "unit_type": unit_type,
            "unit_size": preview_unit['size'],
            "movement_points": str(base_stats['movement']),
            "attack_range": str(base_stats['attack_range']),
            "attack_value": str(base_stats['attack_value']),
            "combat_value": str(base_stats['combat_value']),
            "defense_value": str(base_stats['defense_value']),
            "unit_maintenance": str(base_stats['maintenance']),
            "purchase_value": str(cost),
            "sight_range": str(base_stats['sight']),
            "support": base_stats.get('support', "")
        }
    
    def generate_unit_stats(self, unit_type, unit_size, cost):
        """Generuje statystyki jednostki na podstawie typu, rozmiaru i kosztu."""
        
        # Bazowe statystyki dla typ√≥w jednostek
        base_stats = {
            "P": {"movement": 3, "attack_range": 1, "attack_value": 8, "combat_value": 8, "defense_value": 10, "sight": 3},
            "K": {"movement": 6, "attack_range": 1, "attack_value": 6, "combat_value": 6, "defense_value": 8, "sight": 5},
            "TL": {"movement": 5, "attack_range": 1, "attack_value": 10, "combat_value": 10, "defense_value": 12, "sight": 3},
            "T≈ö": {"movement": 4, "attack_range": 2, "attack_value": 14, "combat_value": 14, "defense_value": 16, "sight": 3},
            "TC": {"movement": 3, "attack_range": 2, "attack_value": 18, "combat_value": 18, "defense_value": 22, "sight": 3},
            "TS": {"movement": 5, "attack_range": 1, "attack_value": 8, "combat_value": 8, "defense_value": 10, "sight": 4},
            "AL": {"movement": 3, "attack_range": 3, "attack_value": 12, "combat_value": 6, "defense_value": 6, "sight": 4},
            "AC": {"movement": 2, "attack_range": 4, "attack_value": 18, "combat_value": 8, "defense_value": 8, "sight": 5},
            "AP": {"movement": 2, "attack_range": 2, "attack_value": 10, "combat_value": 6, "defense_value": 8, "sight": 4},
            "Z": {"movement": 6, "attack_range": 1, "attack_value": 4, "combat_value": 4, "defense_value": 6, "sight": 6},
            "D": {"movement": 4, "attack_range": 1, "attack_value": 6, "combat_value": 8, "defense_value": 12, "sight": 5}
        }
        
        stats = base_stats.get(unit_type, base_stats["P"]).copy()
        
        # Modyfikatory na podstawie rozmiaru jednostki
        size_multipliers = {
            "Pluton": 1.0,
            "Kompania": 1.4,
            "Batalion": 1.8
        }
        
        multiplier = size_multipliers.get(unit_size, 1.0)
        
        # Skaluj statystyki bojowe
        stats["attack_value"] = int(stats["attack_value"] * multiplier)
        stats["combat_value"] = int(stats["combat_value"] * multiplier)
        stats["defense_value"] = int(stats["defense_value"] * multiplier)
        
        # Utrzymanie na podstawie kosztu
        stats["maintenance"] = max(1, cost // 15)
        
        # Dodaj losowƒÖ wariacjƒô ¬±15%
        for key in ["attack_value", "combat_value", "defense_value"]:
            variation = random.uniform(0.85, 1.15)
            stats[key] = max(1, int(stats[key] * variation))
        
        return stats
    
    def initialize_token_editor(self):
        """Inicjalizuje Token Editor w dedykowanym oknie."""
        if self.token_editor is None:
            from edytory.token_editor_prototyp import TokenEditor
            
            # Utw√≥rz dedykowane okno dla Token Editor
            token_window = tk.Toplevel(self.root)
            token_window.title("Token Editor - Tryb Automatyczny")
            token_window.geometry("400x300")  # Mniejsze okno
            token_window.configure(bg="darkolivegreen")
            
            # Przesu≈Ñ okno poza g≈Ç√≥wny obszar
            token_window.geometry("+50+50")
            
            # Zminimalizuj okno ale nie ukrywaj go ca≈Çkowicie
            token_window.iconify()
            
            self.token_editor = TokenEditor(token_window)
            
            # Dodaj informacjƒô o trybie automatycznym
            info_label = tk.Label(token_window, 
                                text="ü§ñ TRYB AUTOMATYCZNY\nToken Editor pracuje w tle...", 
                                bg="darkolivegreen", fg="white", 
                                font=("Arial", 12, "bold"))
            info_label.pack(expand=True)
    
    def create_single_token(self, unit):
        """Tworzy pojedynczy ≈ºeton u≈ºywajƒÖc Token Editor."""
        try:
            # Ustaw parametry w Token Editor
            commander = self.selected_commander.get()
            
            if hasattr(self.token_editor, 'selected_commander'):
                self.token_editor.selected_commander.set(commander)
            
            self.token_editor.nation.set(unit["nation"])
            self.token_editor.unit_type.set(unit["unit_type"])
            self.token_editor.unit_size.set(unit["unit_size"])
            
            # Ustaw statystyki
            self.token_editor.movement_points.set(unit["movement_points"])
            self.token_editor.attack_range.set(unit["attack_range"])
            self.token_editor.attack_value.set(unit["attack_value"])
            self.token_editor.combat_value.set(unit["combat_value"])
            self.token_editor.defense_value.set(unit["defense_value"])
            self.token_editor.unit_maintenance.set(unit["unit_maintenance"])
            self.token_editor.purchase_value.set(unit["purchase_value"])
            self.token_editor.sight_range.set(unit["sight_range"])
            
            # Wsparcie
            if unit["support"] and hasattr(self.token_editor, 'selected_support'):
                self.token_editor.selected_support.set(unit["support"])
            
            # Wygeneruj podglƒÖd
            self.token_editor.update_preview()
              # Zapisz ≈ºeton z mockami dialog√≥w
            with patch('tkinter.messagebox.askyesno', return_value=True), \
                 patch('tkinter.messagebox.showinfo', return_value=None), \
                 patch('tkinter.simpledialog.askstring', return_value=unit['name']):
                self.token_editor.save_token()
            
            return True
            
        except Exception as e:
            print(f"B≈ÇƒÖd tworzenia ≈ºetonu {unit['name']}: {e}")
            return False
    
    def update_creation_progress(self, progress, message):
        """Aktualizuje progress bar i wiadomo≈õƒá."""
        self.progress_bar['value'] = progress
        self.progress_label.config(text=message)
        self.status_label.config(text=f"üè≠ {message}")
    
    def creation_completed(self, units_created):
        """Obs≈Çuguje zako≈Ñczenie tworzenia armii."""
        self.creating_army = False
        self.progress_bar['value'] = 100
        self.progress_label.config(text=f"‚úÖ Utworzono {units_created} ≈ºeton√≥w!")
        self.status_label.config(text=f"üéâ Armia uko≈Ñczona! Utworzono {units_created} ≈ºeton√≥w")
        
        self.create_button.config(state='normal', text="üíæ UTW√ìRZ ARMIƒò")
        
        # Wy≈õwietl podsumowanie
        messagebox.showinfo("üéâ Sukces!", 
                           f"Armia zosta≈Ça pomy≈õlnie utworzona!\n\n"
                           f"üìä Utworzono: {units_created} ≈ºeton√≥w\n"
                           f"üéñÔ∏è Dow√≥dca: {self.selected_commander.get()}\n"
                           f"üè¥ Nacja: {self.selected_nation.get()}\n"
                           f"üí∞ Bud≈ºet: {self.army_budget.get()} VP\n\n"                           f"≈ªetony zapisane w katalogu assets/tokens/")
    
    def creation_failed(self, error_message):
        """Obs≈Çuguje b≈ÇƒÖd podczas tworzenia armii."""
        self.creating_army = False
        self.progress_label.config(text="‚ùå B≈ÇƒÖd tworzenia armii")
        self.status_label.config(text="‚ùå B≈ÇƒÖd podczas tworzenia armii")
        
        self.create_button.config(state='normal', text="üíæ UTW√ìRZ ARMIƒò")
        
        messagebox.showerror("‚ùå B≈ÇƒÖd", 
                            f"WystƒÖpi≈Ç b≈ÇƒÖd podczas tworzenia armii:\n\n{error_message}")
    
    # === FUNKCJE ZARZƒÑDZANIA FOLDERAMI ===
    
    def refresh_token_stats(self):
        """Od≈õwie≈ºa statystyki ≈ºeton√≥w w folderach."""
        try:
            tokens_dir = Path("assets/tokens")
            if not tokens_dir.exists():
                self.stats_label.config(text="üìÇ Folder assets/tokens nie istnieje")
                return
            
            # Sprawd≈∫ foldery nacji
            polish_count, polish_vp = self.count_nation_tokens("Polska")
            german_count, german_vp = self.count_nation_tokens("Niemcy")
            
            stats_text = f"üìä STATYSTYKI ≈ªETON√ìW:\n"
            stats_text += f"üáµüá± Polska: {polish_count} ≈ºeton√≥w ({polish_vp} VP)\n"
            stats_text += f"üá©üá™ Niemcy: {german_count} ≈ºeton√≥w ({german_vp} VP)"
            
            self.stats_label.config(text=stats_text)
            
        except Exception as e:
            self.stats_label.config(text=f"‚ùå B≈ÇƒÖd: {str(e)}")
    
    def count_nation_tokens(self, nation):
        """Zlicza ≈ºetony i VP dla danej nacji."""
        tokens_dir = Path(f"assets/tokens/{nation}")
        if not tokens_dir.exists():
            return 0, 0
        
        count = 0
        total_vp = 0
        
        for token_folder in tokens_dir.iterdir():
            if token_folder.is_dir():
                json_file = token_folder / "token.json"
                if json_file.exists():
                    count += 1
                    try:
                        with open(json_file, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                            total_vp += int(data.get('purchase_value', 0))
                    except:
                        pass  # Ignoruj b≈Çƒôdy odczytu
        
        return count, total_vp
    
    def clean_polish_tokens(self):
        """Czy≈õci polskie ≈ºetony z potwierdzeniem."""
        print("üîç DEBUG: clean_polish_tokens() - WYWO≈ÅANA!")
        print(f"üîç DEBUG: Przekazujƒô do clean_nation_tokens('Polska', 'üáµüá±')")
        self.clean_nation_tokens("Polska", "üáµüá±")
    
    def clean_german_tokens(self):
        """Czy≈õci niemieckie ≈ºetony z potwierdzeniem."""
        print("üîç DEBUG: clean_german_tokens() - WYWO≈ÅANA!")
        print(f"üîç DEBUG: Przekazujƒô do clean_nation_tokens('Niemcy', 'üá©üá™')")
        self.clean_nation_tokens("Niemcy", "üá©üá™")
    
    def clean_all_tokens(self):
        """Czy≈õci wszystkie ≈ºetony z potwierdzeniem."""
        if messagebox.askyesno("‚ö†Ô∏è UWAGA!", 
                              "Czy na pewno chcesz usunƒÖƒá WSZYSTKIE ≈ºetony?\n\n"
                              "Ta operacja nie mo≈ºe byƒá cofniƒôta!\n\n"
                              "üóëÔ∏è ZostanƒÖ usuniƒôte:\n"
                              "‚Ä¢ Wszystkie polskie ≈ºetony\n"
                              "‚Ä¢ Wszystkie niemieckie ≈ºetony\n"                              "‚Ä¢ Plik index.json"):
            
            try:
                tokens_dir = Path("assets/tokens")
                
                if tokens_dir.exists():
                    # Usu≈Ñ foldery nacji
                    for nation_dir in tokens_dir.iterdir():
                        if nation_dir.is_dir() and nation_dir.name in ["Polska", "Niemcy"]:
                            shutil.rmtree(nation_dir)
                      # Usu≈Ñ index.json
                    index_file = tokens_dir / "index.json"
                    if index_file.exists():
                        index_file.unlink()
                
                # Wyczy≈õƒá start_tokens.json
                print("üîç DEBUG: Czyszczƒô start_tokens.json...")
                self.clear_all_start_tokens()
                
                self.refresh_token_stats()
                messagebox.showinfo("‚úÖ Sukces!", "Wszystkie ≈ºetony zosta≈Çy usuniƒôte.\nMapa zosta≈Ça wyczyszczona z ≈ºeton√≥w.")
                
            except Exception as e:                messagebox.showerror("‚ùå B≈ÇƒÖd", f"B≈ÇƒÖd podczas usuwania:\n{str(e)}")
    
    def clean_nation_tokens(self, nation, flag):
        """Czy≈õci ≈ºetony wybranej nacji z potwierdzeniem."""
        print(f"üîç DEBUG: clean_nation_tokens() - WYWO≈ÅANA dla {nation} {flag}")
        
        # Sprawd≈∫ ile ≈ºeton√≥w do usuniƒôcia
        print(f"üîç DEBUG: Sprawdzam ≈ºetony dla {nation}...")
        count, vp = self.count_nation_tokens(nation)
        print(f"üîç DEBUG: Znaleziono {count} ≈ºeton√≥w, {vp} VP dla {nation}")        
        if count == 0:
            print(f"üîç DEBUG: Brak ≈ºeton√≥w {nation} - wy≈õwietlam dialog info")
            messagebox.showinfo("‚ÑπÔ∏è Info", f"Brak ≈ºeton√≥w {flag} {nation} do usuniƒôcia.")
            return
        
        print(f"üîç DEBUG: Wy≈õwietlam dialog potwierdzenia dla {count} ≈ºeton√≥w {nation}")
        if messagebox.askyesno("‚ö†Ô∏è POTWIERD≈π USUNIƒòCIE",
                              f"Czy na pewno chcesz usunƒÖƒá ≈ºetony {flag} {nation}?\n\n"
                              f"üóëÔ∏è Do usuniƒôcia:\n"
                              f"‚Ä¢ {count} ≈ºeton√≥w\n"
                              f"‚Ä¢ {vp} VP ≈ÇƒÖcznie\n\n"                              f"Ta operacja nie mo≈ºe byƒá cofniƒôta!"):
            
            print(f"üîç DEBUG: U≈ºytkownik potwierdzi≈Ç usuniƒôcie {nation}")
            
            try:
                nation_dir = Path(f"assets/tokens/{nation}")
                print(f"üîç DEBUG: Pr√≥bujƒô usunƒÖƒá folder: {nation_dir}")
                print(f"üîç DEBUG: Folder istnieje: {nation_dir.exists()}")
                
                if nation_dir.exists():
                    print(f"üîç DEBUG: Wywo≈Çujƒô shutil.rmtree({nation_dir})")
                    shutil.rmtree(nation_dir)
                    print(f"üîç DEBUG: shutil.rmtree() zako≈Ñczone!")
                    print(f"üîç DEBUG: Folder istnieje po usuniƒôciu: {nation_dir.exists()}")
                  # Aktualizuj index.json
                print(f"üîç DEBUG: Aktualizujƒô index.json...")
                self.update_index_after_deletion(nation)
                
                # Wyczy≈õƒá start_tokens.json dla usuwanej nacji
                print(f"üîç DEBUG: Czyszczƒô start_tokens.json dla {nation}...")
                self.clear_nation_from_start_tokens(nation)
                
                print(f"üîç DEBUG: Od≈õwie≈ºam statystyki...")
                self.refresh_token_stats()
                
                print(f"üîç DEBUG: Wy≈õwietlam dialog sukcesu...")
                messagebox.showinfo("‚úÖ Sukces!", 
                                   f"Usuniƒôto {count} ≈ºeton√≥w {flag} {nation} ({vp} VP).\n"
                                   f"Mapa zosta≈Ça wyczyszczona z ≈ºeton√≥w tej nacji.")
                print(f"üîç DEBUG: Operacja zako≈Ñczona pomy≈õlnie!")
                
            except Exception as e:
                print(f"üîç DEBUG: B≈ÅƒÑD podczas usuwania: {e}")
                print(f"üîç DEBUG: Typ b≈Çƒôdu: {type(e).__name__}")
                messagebox.showerror("‚ùå B≈ÇƒÖd", f"B≈ÇƒÖd podczas usuwania:\n{str(e)}")
        else:
            print(f"üîç DEBUG: U≈ºytkownik anulowa≈Ç usuniƒôcie {nation}")
    
    def update_index_after_deletion(self, deleted_nation):
        """Aktualizuje index.json po usuniƒôciu ≈ºeton√≥w nacji."""
        try:
            index_file = Path("assets/tokens/index.json")
            if not index_file.exists():
                return
            
            with open(index_file, 'r', encoding='utf-8') as f:
                index_data = json.load(f)
            
            # Usu≈Ñ ≈ºetony usuniƒôtej nacji z indeksu
            if deleted_nation in index_data:
                del index_data[deleted_nation]
            
            # Zapisz zaktualizowany indeks
            with open(index_file, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, indent=2, ensure_ascii=False)
                
        except Exception as e:
            print(f"B≈ÇƒÖd aktualizacji index.json: {e}")
    
    def clear_nation_from_start_tokens(self, nation):
        """Usuwa ≈ºetony wybranej nacji z start_tokens.json."""
        try:
            start_tokens_path = Path("assets/start_tokens.json")
            print(f"üîç DEBUG: clear_nation_from_start_tokens() - ≈õcie≈ºka: {start_tokens_path}")
            
            if not start_tokens_path.exists():
                print(f"üîç DEBUG: Plik start_tokens.json nie istnieje - tworzƒô pusty")
                empty_data = {"tokens": {}}
                with open(start_tokens_path, 'w', encoding='utf-8') as f:
                    json.dump(empty_data, f, indent=2, ensure_ascii=False)
                return
            
            # Wczytaj istniejƒÖce dane
            with open(start_tokens_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            tokens = data.get("tokens", {})
            print(f"üîç DEBUG: Wczytano {len(tokens)} ≈ºeton√≥w z start_tokens.json")
            
            # Znajd≈∫ ≈ºetony do usuniƒôcia (po prefiksie nazwy)
            tokens_to_remove = []
            for token_id, token_data in tokens.items():
                token_name = token_data.get("name", "")
                # Sprawd≈∫ czy ≈ºeton nale≈ºy do usuwanej nacji (na podstawie nazwy)
                if (nation == "Polska" and any(prefix in token_name.lower() for prefix in ["pol", "poland", "1939_pol"])) or \
                   (nation == "Niemcy" and any(prefix in token_name.lower() for prefix in ["ger", "german", "1939_ger"])):
                    tokens_to_remove.append(token_id)
            
            print(f"üîç DEBUG: Znaleziono {len(tokens_to_remove)} ≈ºeton√≥w {nation} do usuniƒôcia z mapy")
            
            # Usu≈Ñ ≈ºetony
            for token_id in tokens_to_remove:
                del tokens[token_id]
            
            # Zapisz zaktualizowane dane
            data["tokens"] = tokens
            with open(start_tokens_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            print(f"‚úÖ DEBUG: Usuniƒôto {len(tokens_to_remove)} ≈ºeton√≥w {nation} z start_tokens.json")
            
        except Exception as e:
            print(f"‚ùå B≈ÅƒÑD clear_nation_from_start_tokens: {e}")
    
    def clear_all_start_tokens(self):
        """Usuwa wszystkie ≈ºetony z start_tokens.json."""
        try:
            start_tokens_path = Path("assets/start_tokens.json")
            print(f"üîç DEBUG: clear_all_start_tokens() - ≈õcie≈ºka: {start_tokens_path}")
            
            empty_data = {"tokens": {}}
            
            with open(start_tokens_path, 'w', encoding='utf-8') as f:
                json.dump(empty_data, f, indent=2, ensure_ascii=False)
            
            print(f"‚úÖ DEBUG: Wyczyszczono start_tokens.json - wszystkie ≈ºetony usuniƒôte z mapy")
            
        except Exception as e:
            print(f"‚ùå B≈ÅƒÑD clear_all_start_tokens: {e}")

    def deploy_army_to_map(self):
        """Rozstawia utworzonƒÖ armiƒô na mapie wed≈Çug wybranej ƒáwiartki."""
        try:
            print("üîç DEBUG: deploy_army_to_map() - WYWO≈ÅANA!")
            print(f"üîç DEBUG: self.created_units = {self.created_units}")
            print(f"üîç DEBUG: len(self.created_units) = {len(self.created_units) if self.created_units else None}")
            
            # Sprawd≈∫ czy armia zosta≈Ça utworzona (albo w zmiennej albo w folderach)
            if not self.created_units:
                print("‚ùå DEBUG: Brak self.created_units - sprawdzam foldery ≈ºeton√≥w...")
                
                # Sprawd≈∫ czy sƒÖ ≈ºetony w folderach
                nation = self.selected_nation.get()
                print(f"üîç DEBUG: Sprawdzam ≈ºetony dla nacji: {nation}")
                
                tokens_folder = Path(f"assets/tokens/{nation}")
                print(f"üîç DEBUG: ≈öcie≈ºka foldera: {tokens_folder}")
                print(f"üîç DEBUG: Folder istnieje: {tokens_folder.exists()}")
                
                if tokens_folder.exists():
                    token_folders = [f.name for f in tokens_folder.iterdir() if f.is_dir()]
                    print(f"üîç DEBUG: Znalezione foldery ≈ºeton√≥w: {token_folders}")
                    
                    if token_folders:
                        print(f"‚úÖ DEBUG: Znaleziono {len(token_folders)} ≈ºeton√≥w w folderach")
                        # Wczytaj ≈ºetony z folder√≥w
                        self.created_units = self.load_tokens_from_folders(nation)
                        print(f"üîç DEBUG: Wczytane ≈ºetony: {len(self.created_units)} sztuk")
                        print("‚úÖ DEBUG: ≈ªetony wczytane z folder√≥w do self.created_units")
                    else:
                        print("‚ùå DEBUG: Brak folder√≥w ≈ºeton√≥w")
                        messagebox.showwarning("‚ö†Ô∏è Uwaga", 
                                             f"Brak ≈ºeton√≥w dla nacji {nation}!\n\n"
                                             f"Najpierw utw√≥rz armiƒô, a potem jƒÖ rozstaw!")
                        return
                else:
                    print("‚ùå DEBUG: Folder ≈ºeton√≥w nie istnieje")
                    messagebox.showwarning("‚ö†Ô∏è Uwaga", 
                                         "Najpierw utw√≥rz armiƒô, a potem jƒÖ rozstaw!")
                    return
            
            print(f"‚úÖ DEBUG: Mamy {len(self.created_units)} ≈ºeton√≥w do rozstawienia")
            
            # Pobierz parametry
            nation = self.selected_nation.get()
            commander = self.selected_commander.get()
            print(f"üîç DEBUG: Nacja: {nation}, Dow√≥dca: {commander}")
            
            # Znajd≈∫ odpowiedniƒÖ ƒáwiartkƒô
            quarter = self.get_quarter_for_nation_and_commander(nation, commander)
            print(f"üîç DEBUG: Wybrana ƒáwiartka: {quarter['description']}")
            
            # Potwierd≈∫ rozstawianie
            if messagebox.askyesno("üó∫Ô∏è ROZSTAWIANIE ARMII",
                                  f"Rozstawiƒá armiƒô w ƒáwiartce:\n\n"
                                  f"üìç {quarter['description']}\n"
                                  f"üìä {len(self.created_units)} ≈ºeton√≥w\n"
                                  f"üéñÔ∏è Dow√≥dca: {commander}\n\n"
                                  f"Kontynuowaƒá?"):
                
                print("‚úÖ DEBUG: U≈ºytkownik potwierdzi≈Ç rozstawianie")
                deployed_count = self.perform_army_deployment(quarter)
                messagebox.showinfo("‚úÖ Sukces!", 
                                   f"Rozstawiono {deployed_count} ≈ºeton√≥w\n"
                                   f"w ƒáwiartce {quarter['description']}")
            else:
                print("‚ùå DEBUG: U≈ºytkownik anulowa≈Ç rozstawianie")
                
        except Exception as e:
            print(f"‚ùå DEBUG: B≈ÅƒÑD w deploy_army_to_map: {str(e)}")
            print(f"‚ùå DEBUG: Typ b≈Çƒôdu: {type(e).__name__}")
            messagebox.showerror("‚ùå B≈ÇƒÖd", f"B≈ÇƒÖd rozstawiania: {str(e)}")
    
    def load_tokens_from_folders(self, nation):
        """Wczytuje ≈ºetony z folder√≥w dla danej nacji."""
        print(f"üîç DEBUG: load_tokens_from_folders({nation}) - WYWO≈ÅANA!")
        tokens = []
        
        tokens_folder = Path(f"assets/tokens/{nation}")
        print(f"üîç DEBUG: Sprawdzam folder: {tokens_folder}")
        
        if tokens_folder.exists():
            for token_folder in tokens_folder.iterdir():
                if token_folder.is_dir():
                    print(f"üîç DEBUG: Sprawdzam folder ≈ºetonu: {token_folder.name}")
                    token_json = token_folder / "token.json"
                    if token_json.exists():
                        try:
                            with open(token_json, 'r', encoding='utf-8') as f:
                                token_data = json.load(f)
                                tokens.append({
                                    'name': token_folder.name,
                                    'data': token_data
                                })
                                print(f"‚úÖ DEBUG: Wczytano ≈ºeton: {token_folder.name}")
                        except Exception as e:
                            print(f"‚ùå DEBUG: B≈ÇƒÖd wczytywania {token_folder.name}: {e}")
        
        print(f"‚úÖ DEBUG: ≈ÅƒÖcznie wczytano {len(tokens)} ≈ºeton√≥w z folder√≥w")
        return tokens
    
    def preview_quarter_info(self):
        """Pokazuje informacje o wybranej ƒáwiartce."""
        try:
            nation = self.selected_nation.get()
            commander = self.selected_commander.get()
            quarter = self.get_quarter_for_nation_and_commander(nation, commander)
            
            # Aktualizuj info label
            info_text = f"üìç {quarter['description']}\n"
            info_text += f"üó∫Ô∏è Q: {quarter['q_min']}-{quarter['q_max']}, "
            info_text += f"R: {quarter['r_min']}-{quarter['r_max']}"
            
            self.quarter_info.config(text=info_text)
            
            # Poka≈º szczeg√≥≈Çy w dialog
            total_hexes = (quarter['q_max'] - quarter['q_min'] + 1) * (quarter['r_max'] - quarter['r_min'] + 1)
            
            messagebox.showinfo("üìã INFORMACJE O ƒÜWIARTCE",
                               f"üéñÔ∏è {quarter['description']}\n\n"
                               f"üìè Wymiary:\n"
                               f"   ‚Ä¢ Q: {quarter['q_min']} do {quarter['q_max']} ({quarter['q_max'] - quarter['q_min'] + 1} kolumn)\n"
                               f"   ‚Ä¢ R: {quarter['r_min']} do {quarter['r_max']} ({quarter['r_max'] - quarter['r_min'] + 1} wierszy)\n\n"
                               f"üìä ≈ÅƒÖcznie heks√≥w: {total_hexes}\n"
                               f"üè¥ Nacja: {quarter['nation']}\n"
                               f"üë§ Dow√≥dca: {quarter['commander']}")
                               
        except Exception as e:
            messagebox.showerror("‚ùå B≈ÇƒÖd", f"B≈ÇƒÖd podglƒÖdu: {str(e)}")
    
    def clear_army_from_map(self):
        """Usuwa armiƒô z mapy (czysci start_tokens.json)."""
        if messagebox.askyesno("üßπ CZYSZCZENIE MAPY",
                              "Czy na pewno chcesz usunƒÖƒá wszystkie ≈ºetony z mapy?\n\n"
                              "Ta operacja wyczy≈õci plik start_tokens.json"):
            try:
                # Wyczy≈õƒá plik start_tokens.json
                start_tokens_path = Path("assets/start_tokens.json")
                
                empty_data = {"tokens": {}}
                
                with open(start_tokens_path, 'w', encoding='utf-8') as f:
                    json.dump(empty_data, f, indent=2, ensure_ascii=False)
                
                messagebox.showinfo("‚úÖ Sukces!", "Mapa zosta≈Ça wyczyszczona z ≈ºeton√≥w.")
                
            except Exception as e:
                messagebox.showerror("‚ùå B≈ÇƒÖd", f"B≈ÇƒÖd czyszczenia mapy: {str(e)}")

    def perform_army_deployment(self, quarter):
        """Wykonuje rzeczywiste rozstawianie armii w ƒáwiartce."""
        try:
            print(f"üîç DEBUG: perform_army_deployment() - WYWO≈ÅANA!")
            print(f"üîç DEBUG: ƒÜwiartka: {quarter['description']}")
            print(f"üîç DEBUG: ≈ªetony do rozstawienia: {len(self.created_units)}")
            
            # Wczytaj mapƒô
            map_data_path = Path("data/map_data.json")
            print(f"üîç DEBUG: Sprawdzam map_data.json: {map_data_path}")
            print(f"üîç DEBUG: Plik istnieje: {map_data_path.exists()}")
            
            if not map_data_path.exists():
                raise Exception("Nie znaleziono pliku map_data.json")
            
            with open(map_data_path, 'r', encoding='utf-8') as f:
                map_data = json.load(f)
            
            print(f"‚úÖ DEBUG: Wczytano map_data.json - g≈Ç√≥wne sekcje: {list(map_data.keys())}")
            
            # Pobierz heksy z sekcji terrain
            terrain_data = map_data.get('terrain', {})
            print(f"‚úÖ DEBUG: Sekcja terrain zawiera {len(terrain_data)} heks√≥w")
            
            # Debug: poka≈º przyk≈Çadowe heksy
            example_hexes = list(terrain_data.keys())[:5]
            print(f"üîç DEBUG: Przyk≈Çadowe heksy z terrain: {example_hexes}")
            
            # Znajd≈∫ dostƒôpne heksy w ƒáwiartce
            available_hexes = []
            all_hexes_in_quarter = []
            
            for hex_coord in terrain_data.keys():
                if self.is_hex_in_quarter(hex_coord, quarter):
                    available_hexes.append(hex_coord)
                # Debug: sprawd≈∫ wszystkie mo≈ºliwe heksy w ƒáwiartce
                try:
                    q, r = map(int, hex_coord.split(','))
                    if (quarter["q_min"] <= q <= quarter["q_max"] and 
                        quarter["r_min"] <= r <= quarter["r_max"]):
                        all_hexes_in_quarter.append(hex_coord)
                except:
                    pass
            
            print(f"üîç DEBUG: Dostƒôpne heksy w ƒáwiartce: {len(available_hexes)}")
            print(f"üîç DEBUG: Wszystkie teoretyczne heksy w ƒáwiartce: {len(all_hexes_in_quarter)}")
            print(f"üîç DEBUG: Pierwsze 5 heks√≥w: {available_hexes[:5]}")
            
            # Debug: sprawd≈∫ zakres wsp√≥≈Çrzƒôdnych w mapie
            q_coords = []
            r_coords = []
            for hex_coord in terrain_data.keys():
                try:
                    q, r = map(int, hex_coord.split(','))
                    q_coords.append(q)
                    r_coords.append(r)
                except:
                    pass
            
            if q_coords and r_coords:
                print(f"üîç DEBUG: Rzeczywisty zakres Q w mapie: {min(q_coords)} do {max(q_coords)}")
                print(f"üîç DEBUG: Rzeczywisty zakres R w mapie: {min(r_coords)} do {max(r_coords)}")
                print(f"üîç DEBUG: ƒÜwiartka oczekuje Q: {quarter['q_min']}-{quarter['q_max']}, R: {quarter['r_min']}-{quarter['r_max']}")
            
            if not available_hexes:
                print("‚ùå DEBUG: Brak dostƒôpnych heks√≥w w ƒáwiartce!")
                # Sprawd≈∫ czy ƒáwiartka w og√≥le pokrywa siƒô z mapƒÖ
                print(f"üîç DEBUG: Sprawdzam pokrycie ƒáwiartki z mapƒÖ...")
                if q_coords and r_coords:
                    map_q_min, map_q_max = min(q_coords), max(q_coords)
                    map_r_min, map_r_max = min(r_coords), max(r_coords)
                    
                    overlap_q = not (quarter['q_max'] < map_q_min or quarter['q_min'] > map_q_max)
                    overlap_r = not (quarter['r_max'] < map_r_min or quarter['r_min'] > map_r_max)
                    
                    print(f"üîç DEBUG: Pokrycie Q: {overlap_q}, Pokrycie R: {overlap_r}")
                    
                    if not overlap_q or not overlap_r:
                        raise Exception(f"ƒÜwiartka {quarter['description']} nie pokrywa siƒô z mapƒÖ!\n"
                                      f"Mapa: Q({map_q_min}-{map_q_max}), R({map_r_min}-{map_r_max})\n"
                                      f"ƒÜwiartka: Q({quarter['q_min']}-{quarter['q_max']}), R({quarter['r_min']}-{quarter['r_max']})")
                
                raise Exception(f"Brak dostƒôpnych heks√≥w w ƒáwiartce {quarter['description']}")
              # Losowo rozstaw ≈ºetony
            random.shuffle(available_hexes)
            
            deployed_tokens = []
            deployed_count = 0
            
            for i, unit in enumerate(self.created_units):
                if i >= len(available_hexes):
                    print(f"‚ö†Ô∏è DEBUG: Wiƒôcej ≈ºeton√≥w ({len(self.created_units)}) ni≈º dostƒôpnych heks√≥w ({len(available_hexes)})")
                    break  # Wiƒôcej ≈ºeton√≥w ni≈º dostƒôpnych heks√≥w
                
                hex_coord = available_hexes[i]
                token_name = unit.get('name', f'token_{i}')
                
                # Parsuj wsp√≥≈Çrzƒôdne
                q, r = map(int, hex_coord.split(','))
                
                # Format zgodny z load_tokens
                deployed_tokens.append({
                    "id": token_name,
                    "q": q,
                    "r": r
                })
                deployed_count += 1
                
                if i < 5:  # Debug pierwszych 5
                    print(f"üîç DEBUG: Rozstawiam ≈ºeton {i+1}: {token_name} na {hex_coord}")
            
            print(f"‚úÖ DEBUG: Rozstawiono {deployed_count} ≈ºeton√≥w")
            
            # Zapisz do start_tokens.json - format to lista, nie s≈Çownik!
            start_tokens_path = Path("assets/start_tokens.json")
            start_tokens_path.parent.mkdir(exist_ok=True)
            
            start_tokens_data = deployed_tokens
            
            with open(start_tokens_path, 'w', encoding='utf-8') as f:
                json.dump(start_tokens_data, f, indent=2, ensure_ascii=False)
            
            print(f"‚úÖ DEBUG: Zapisano do {start_tokens_path}")
            
            return deployed_count
            
        except Exception as e:
            print(f"‚ùå DEBUG: B≈ÅƒÑD w perform_army_deployment: {str(e)}")
            print(f"‚ùå DEBUG: Typ b≈Çƒôdu: {type(e).__name__}")
            raise Exception(f"B≈ÇƒÖd podczas rozstawiania: {str(e)}")

def main():
    """G≈Ç√≥wna funkcja aplikacji."""
    root = tk.Tk()
    app = ArmyCreatorStudio(root)
    
    # Wy≈õrodkuj okno na ekranie
    root.update_idletasks()
    x = (root.winfo_screenwidth() // 2) - (root.winfo_width() // 2)
    y = (root.winfo_screenheight() // 2) - (root.winfo_height() // 2)
    root.geometry(f"+{x}+{y}")
    
    root.mainloop()

if __name__ == "__main__":
    main()
